"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "pages/api/eth";
exports.ids = ["pages/api/eth"];
exports.modules = {

/***/ "next/dist/compiled/next-server/pages-api.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/pages-api.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/pages-api.runtime.dev.js");

/***/ }),

/***/ "@vercel/kv":
/*!*****************************!*\
  !*** external "@vercel/kv" ***!
  \*****************************/
/***/ ((module) => {

module.exports = import("@vercel/kv");;

/***/ }),

/***/ "ethers":
/*!*************************!*\
  !*** external "ethers" ***!
  \*************************/
/***/ ((module) => {

module.exports = import("ethers");;

/***/ }),

/***/ "zlib":
/*!***********************!*\
  !*** external "zlib" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("zlib");

/***/ }),

/***/ "(api)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Feth&preferredRegion=&absolutePagePath=.%2Fpages%2Fapi%2Feth.ts&middlewareConfigBase64=e30%3D!":
/*!************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Feth&preferredRegion=&absolutePagePath=.%2Fpages%2Fapi%2Feth.ts&middlewareConfigBase64=e30%3D! ***!
  \************************************************************************************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   config: () => (/* binding */ config),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   routeModule: () => (/* binding */ routeModule)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/future/route-modules/pages-api/module.compiled */ \"(api)/./node_modules/next/dist/server/future/route-modules/pages-api/module.compiled.js\");\n/* harmony import */ var next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/future/route-kind */ \"(api)/./node_modules/next/dist/server/future/route-kind.js\");\n/* harmony import */ var next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/build/templates/helpers */ \"(api)/./node_modules/next/dist/build/templates/helpers.js\");\n/* harmony import */ var _pages_api_eth_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./pages/api/eth.ts */ \"(api)/./pages/api/eth.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_pages_api_eth_ts__WEBPACK_IMPORTED_MODULE_3__]);\n_pages_api_eth_ts__WEBPACK_IMPORTED_MODULE_3__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n\n// Import the userland code.\n\n// Re-export the handler (should be the default export).\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_pages_api_eth_ts__WEBPACK_IMPORTED_MODULE_3__, \"default\"));\n// Re-export config.\nconst config = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_pages_api_eth_ts__WEBPACK_IMPORTED_MODULE_3__, \"config\");\n// Create and export the route module that will be consumed.\nconst routeModule = new next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__.PagesAPIRouteModule({\n    definition: {\n        kind: next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.PAGES_API,\n        page: \"/api/eth\",\n        pathname: \"/api/eth\",\n        // The following aren't used in production.\n        bundlePath: \"\",\n        filename: \"\"\n    },\n    userland: _pages_api_eth_ts__WEBPACK_IMPORTED_MODULE_3__\n});\n\n//# sourceMappingURL=pages-api.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LXJvdXRlLWxvYWRlci9pbmRleC5qcz9raW5kPVBBR0VTX0FQSSZwYWdlPSUyRmFwaSUyRmV0aCZwcmVmZXJyZWRSZWdpb249JmFic29sdXRlUGFnZVBhdGg9LiUyRnBhZ2VzJTJGYXBpJTJGZXRoLnRzJm1pZGRsZXdhcmVDb25maWdCYXNlNjQ9ZTMwJTNEISIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFzRztBQUN2QztBQUNMO0FBQzFEO0FBQytDO0FBQy9DO0FBQ0EsaUVBQWUsd0VBQUssQ0FBQyw4Q0FBUSxZQUFZLEVBQUM7QUFDMUM7QUFDTyxlQUFlLHdFQUFLLENBQUMsOENBQVE7QUFDcEM7QUFDTyx3QkFBd0IsZ0hBQW1CO0FBQ2xEO0FBQ0EsY0FBYyx5RUFBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLFlBQVk7QUFDWixDQUFDOztBQUVELHFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2hvd2Rvd24td2lucmF0ZS8/ZGU2ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQYWdlc0FQSVJvdXRlTW9kdWxlIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvZnV0dXJlL3JvdXRlLW1vZHVsZXMvcGFnZXMtYXBpL21vZHVsZS5jb21waWxlZFwiO1xuaW1wb3J0IHsgUm91dGVLaW5kIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvZnV0dXJlL3JvdXRlLWtpbmRcIjtcbmltcG9ydCB7IGhvaXN0IH0gZnJvbSBcIm5leHQvZGlzdC9idWlsZC90ZW1wbGF0ZXMvaGVscGVyc1wiO1xuLy8gSW1wb3J0IHRoZSB1c2VybGFuZCBjb2RlLlxuaW1wb3J0ICogYXMgdXNlcmxhbmQgZnJvbSBcIi4vcGFnZXMvYXBpL2V0aC50c1wiO1xuLy8gUmUtZXhwb3J0IHRoZSBoYW5kbGVyIChzaG91bGQgYmUgdGhlIGRlZmF1bHQgZXhwb3J0KS5cbmV4cG9ydCBkZWZhdWx0IGhvaXN0KHVzZXJsYW5kLCBcImRlZmF1bHRcIik7XG4vLyBSZS1leHBvcnQgY29uZmlnLlxuZXhwb3J0IGNvbnN0IGNvbmZpZyA9IGhvaXN0KHVzZXJsYW5kLCBcImNvbmZpZ1wiKTtcbi8vIENyZWF0ZSBhbmQgZXhwb3J0IHRoZSByb3V0ZSBtb2R1bGUgdGhhdCB3aWxsIGJlIGNvbnN1bWVkLlxuZXhwb3J0IGNvbnN0IHJvdXRlTW9kdWxlID0gbmV3IFBhZ2VzQVBJUm91dGVNb2R1bGUoe1xuICAgIGRlZmluaXRpb246IHtcbiAgICAgICAga2luZDogUm91dGVLaW5kLlBBR0VTX0FQSSxcbiAgICAgICAgcGFnZTogXCIvYXBpL2V0aFwiLFxuICAgICAgICBwYXRobmFtZTogXCIvYXBpL2V0aFwiLFxuICAgICAgICAvLyBUaGUgZm9sbG93aW5nIGFyZW4ndCB1c2VkIGluIHByb2R1Y3Rpb24uXG4gICAgICAgIGJ1bmRsZVBhdGg6IFwiXCIsXG4gICAgICAgIGZpbGVuYW1lOiBcIlwiXG4gICAgfSxcbiAgICB1c2VybGFuZFxufSk7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhZ2VzLWFwaS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Feth&preferredRegion=&absolutePagePath=.%2Fpages%2Fapi%2Feth.ts&middlewareConfigBase64=e30%3D!\n");

/***/ }),

/***/ "(api)/./pages/api/eth.ts":
/*!**************************!*\
  !*** ./pages/api/eth.ts ***!
  \**************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ handler)\n/* harmony export */ });\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ethers */ \"ethers\");\n/* harmony import */ var zlib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zlib */ \"zlib\");\n/* harmony import */ var zlib__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(zlib__WEBPACK_IMPORTED_MODULE_1__);\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([ethers__WEBPACK_IMPORTED_MODULE_0__]);\nethers__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\nconst RPC = process.env.RPC_URL || \"https://timothy.megaeth.com/mafia/rpc/l1z4x7c0v3b6n9m2a5s8d1f4g7h0j3k6q9w2e5r8\";\nconst CONTRACT = (process.env.CONTRACT_ADDRESS || \"0x86b6f3856f086cd29462985f7bbff0d55d2b5d53\").toLowerCase();\nconst LEGACY_CONTRACT = \"0xae2afe4d192127e6617cfa638a94384b53facec1\".toLowerCase();\nconst LEGACY_TOPIC0 = \"0xccc938abc01344413efee36b5d484cedd3bf4ce93b496e8021ba021fed9e2725\";\nconst TOPIC0 = \"0x95340ecf2fd1c1da827f4cf010d0726c65c2e05684a492c4eeaa6ac1b91babf0\";\n// New contract started around Nov 15, 2025 00:00:00 UTC (legacy contract stopped around then)\nconst NEW_CONTRACT_START_TS = Math.floor(new Date(\"2025-11-15T00:00:00Z\").getTime() / 1000);\nconst MAX_SPAN = 100000;\nconst MAX_DAYS_CACHE = 120;\nconst RPC_RETRY_ATTEMPTS = 6;\nconst RPC_BASE_DELAY_MS = 800;\nconst DAY_RANGE_CONCURRENCY = 10; // Increased for faster KV cache retrieval\nconst LOG_RANGE_CONCURRENCY = 2;\nconst CACHE_NAMESPACE = (process.env.CACHE_NAMESPACE || `${CONTRACT}:${TOPIC0}`).toLowerCase();\nfunction memKey(dayIndex) {\n    return `${CACHE_NAMESPACE}:${dayIndex}`;\n}\nconst dayCache = new Map();\nconst dayOrder = [];\nfunction remember(dayIndex, entry) {\n    const key = memKey(dayIndex);\n    if (!dayCache.has(key)) dayOrder.push(key);\n    dayCache.set(key, entry);\n    while(dayOrder.length > MAX_DAYS_CACHE){\n        const evict = dayOrder.shift();\n        if (evict !== undefined) dayCache.delete(evict);\n    }\n}\nfunction dayIndexFromTs(ts) {\n    return Math.floor(ts / 86400);\n}\nfunction clamp(n, a, b) {\n    return Math.max(a, Math.min(b, n));\n}\n// Optional persistent cache (Vercel KV or Upstash for Redis via REST). Falls back to in-memory only if not configured.\n// We lazily import '@vercel/kv' after normalizing envs so it works with either KV_* or UPSTASH_*.\nconst KV_ENV_PRESENT = !!(process.env.KV_REST_API_URL || process.env.UPSTASH_REDIS_REST_URL);\nfunction kvKey(dayIndex) {\n    return `${CACHE_NAMESPACE}:day:${dayIndex}`;\n}\nfunction kvAggKey(dayIndex) {\n    return `${CACHE_NAMESPACE}:dayAgg:${dayIndex}`;\n}\nfunction legacyKvKey(dayIndex) {\n    return `day:${dayIndex}`;\n}\nfunction legacyKvAggKey(dayIndex) {\n    return `dayAgg:${dayIndex}`;\n}\nlet _kvClient = null;\nasync function getKv() {\n    if (!KV_ENV_PRESENT) return null;\n    // Normalize Upstash â†’ Vercel KV env names if needed\n    if (!process.env.KV_REST_API_URL && process.env.UPSTASH_REDIS_REST_URL) {\n        process.env.KV_REST_API_URL = process.env.UPSTASH_REDIS_REST_URL;\n    }\n    if (!process.env.KV_REST_API_TOKEN && process.env.UPSTASH_REDIS_REST_TOKEN) {\n        process.env.KV_REST_API_TOKEN = process.env.UPSTASH_REDIS_REST_TOKEN;\n    }\n    if (!_kvClient) {\n        const mod = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @vercel/kv */ \"@vercel/kv\"));\n        _kvClient = mod.kv;\n    }\n    return _kvClient;\n}\nasync function kvGetDay(dayIndex) {\n    try {\n        const client = await getKv();\n        if (!client) return null;\n        const dayStartTs = dayIndex * 86400;\n        const needsNewContract = dayStartTs >= NEW_CONTRACT_START_TS;\n        if (needsNewContract) {\n            // For days after Nov 15, ONLY use new contract cache - never fall back to legacy\n            const newKey = await client.get(kvKey(dayIndex));\n            return newKey;\n        } else {\n            // For days before Nov 15, try both keys (legacy might have data)\n            const [newKey, legacyKey] = await Promise.all([\n                client.get(kvKey(dayIndex)),\n                client.get(legacyKvKey(dayIndex))\n            ]);\n            return newKey || legacyKey;\n        }\n    } catch  {\n        return null;\n    }\n}\nfunction computeAgg(rows) {\n    const map = {};\n    for (const r of rows){\n        const w = (r.winningClasses || \"\").trim();\n        const l = (r.losingClasses || \"\").trim();\n        if (w) {\n            if (!map[w]) map[w] = {\n                wins: 0,\n                losses: 0,\n                total: 0\n            };\n            map[w].wins += 1;\n            map[w].total += 1;\n        }\n        if (l) {\n            if (!map[l]) map[l] = {\n                wins: 0,\n                losses: 0,\n                total: 0\n            };\n            map[l].losses += 1;\n            map[l].total += 1;\n        }\n    }\n    return {\n        byClass: map,\n        lastUpdate: Date.now()\n    };\n}\nasync function kvSetDay(dayIndex, entry) {\n    try {\n        const client = await getKv();\n        if (!client) return;\n        await client.set(kvKey(dayIndex), entry);\n        // Also persist aggregates for fast stats\n        const agg = computeAgg(entry.rows);\n        await client.set(kvAggKey(dayIndex), agg);\n    } catch  {}\n}\nconst iface = new ethers__WEBPACK_IMPORTED_MODULE_0__.Interface([\n    \"event GameResultEvent(uint256 gameNumber, string gameId, string startedAt, string winningPlayer, string winningClasses, string losingPlayer, string losingClasses, string gameLength, string endReason, string gameType, string metadata)\"\n]);\nconst legacyIface = new ethers__WEBPACK_IMPORTED_MODULE_0__.Interface([\n    \"event GameResultEvent(uint256 gameNumber, string gameId, string startedAt, string winningPlayer, string winningClasses, string losingPlayer, string losingClasses, string gameLength, string endReason)\"\n]);\nfunction toHex(n) {\n    return \"0x\" + n.toString(16);\n}\nfunction sleep(ms) {\n    return new Promise((r)=>setTimeout(r, ms));\n}\nfunction normalizePlayer(raw) {\n    const val = (raw || \"\").trim();\n    const idx = val.indexOf(\"#\");\n    return idx === -1 ? val : val.slice(0, idx);\n}\nfunction sendJson(res, status, payload) {\n    const json = JSON.stringify(payload);\n    const gz = (0,zlib__WEBPACK_IMPORTED_MODULE_1__.gzipSync)(json);\n    res.setHeader(\"Content-Type\", \"application/json\");\n    res.setHeader(\"Content-Encoding\", \"gzip\");\n    res.status(status).send(gz);\n}\nasync function rpc(body, attempts = RPC_RETRY_ATTEMPTS, baseDelay = RPC_BASE_DELAY_MS) {\n    let lastErr = null;\n    for(let i = 0; i < attempts; i++){\n        try {\n            const res = await fetch(RPC, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify(body)\n            });\n            if (res.status === 429 || res.status === 503) {\n                lastErr = new Error(\"RPC HTTP \" + res.status);\n                const retryAfter = Number(res.headers.get(\"retry-after\"));\n                const wait = retryAfter > 0 ? retryAfter * 1000 : Math.round(baseDelay * Math.pow(1.8, i));\n                await sleep(wait);\n                continue;\n            }\n            if (!res.ok) throw new Error(\"RPC HTTP \" + res.status);\n            const j = await res.json();\n            if (Array.isArray(j)) {\n                const bad = j.find((x)=>x && x.error);\n                if (bad) throw new Error(bad.error?.message || \"RPC batch error\");\n            } else if (j && j.error) {\n                throw new Error(j.error?.message || \"RPC error\");\n            }\n            return j;\n        } catch (e) {\n            lastErr = e;\n            await sleep(Math.round(baseDelay * Math.pow(1.6, i)));\n        }\n    }\n    throw lastErr || new Error(\"RPC failed after retries\");\n}\nasync function getBlockByTag(tag) {\n    const j = await rpc({\n        jsonrpc: \"2.0\",\n        id: 1,\n        method: \"eth_getBlockByNumber\",\n        params: [\n            tag,\n            false\n        ]\n    });\n    const blk = j?.result;\n    if (!blk) throw new Error(\"Block not found\");\n    return {\n        num: parseInt(blk.number, 16),\n        ts: parseInt(blk.timestamp, 16)\n    };\n}\nasync function getBlockByNumber(n) {\n    return getBlockByTag(toHex(n));\n}\nasync function getEarliest() {\n    return getBlockByTag(\"earliest\");\n}\nasync function getLatest() {\n    return getBlockByTag(\"latest\");\n}\nasync function findBlockAtOrAfter(targetTs, bounds) {\n    const earliest = bounds?.earliest ?? await getEarliest();\n    const latest = bounds?.latest ?? await getLatest();\n    const clamped = Math.max(targetTs, earliest.ts);\n    if (clamped <= earliest.ts) return earliest.num;\n    if (clamped > latest.ts) return latest.num;\n    let lo = earliest.num, hi = latest.num;\n    while(lo < hi){\n        const mid = lo + Math.floor((hi - lo) / 2);\n        const b = await getBlockByNumber(mid);\n        if (b.ts >= clamped) hi = mid;\n        else lo = mid + 1;\n    }\n    return lo;\n}\nasync function findBlockAtOrBefore(targetTs, bounds) {\n    const earliest = bounds?.earliest ?? await getEarliest();\n    const latest = bounds?.latest ?? await getLatest();\n    const clamped = Math.min(targetTs, latest.ts);\n    if (clamped < earliest.ts) return earliest.num;\n    if (clamped >= latest.ts) return latest.num;\n    let lo = earliest.num, hi = latest.num;\n    while(lo < hi){\n        const mid = lo + Math.floor((hi - lo + 1) / 2);\n        const b = await getBlockByNumber(mid);\n        if (b.ts <= clamped) lo = mid;\n        else hi = mid - 1;\n    }\n    return lo;\n}\nfunction buildRanges(fromBlock, toBlock) {\n    const ranges = [];\n    let s = fromBlock;\n    while(s <= toBlock){\n        const e = Math.min(s + MAX_SPAN - 1, toBlock);\n        ranges.push({\n            from: s,\n            to: e\n        });\n        s = e + 1;\n    }\n    return ranges;\n}\nasync function getLogsSingle(fromBlock, toBlock, contract = CONTRACT, topic0 = TOPIC0) {\n    const j = await rpc({\n        jsonrpc: \"2.0\",\n        id: 1,\n        method: \"eth_getLogs\",\n        params: [\n            {\n                fromBlock: toHex(fromBlock),\n                toBlock: toHex(toBlock),\n                address: contract,\n                topics: [\n                    topic0\n                ]\n            }\n        ]\n    });\n    const arr = j?.result || [];\n    // Defensive: some RPC providers can occasionally return duplicate logs in large ranges\n    const uniq = new Map();\n    for (const log of arr){\n        const key = `${log.transactionHash}-${parseInt(log.logIndex, 16)}`;\n        uniq.set(key, log);\n    }\n    return Array.from(uniq.values());\n}\nasync function getLogsChunked(fromBlock, toBlock, contract = CONTRACT, topic0 = TOPIC0) {\n    const ranges = buildRanges(fromBlock, toBlock);\n    let all = [];\n    const CONCURRENCY = Math.max(1, LOG_RANGE_CONCURRENCY);\n    for(let i = 0; i < ranges.length; i += CONCURRENCY){\n        const slice = ranges.slice(i, i + CONCURRENCY);\n        const reqs = slice.map((r, idx)=>rpc({\n                jsonrpc: \"2.0\",\n                id: 1000 + i + idx,\n                method: \"eth_getLogs\",\n                params: [\n                    {\n                        fromBlock: toHex(r.from),\n                        toBlock: toHex(r.to),\n                        address: contract,\n                        topics: [\n                            topic0\n                        ]\n                    }\n                ]\n            }));\n        const parts = await Promise.all(reqs);\n        for (const p of parts)all.push(...p?.result || []);\n    }\n    const uniq = new Map();\n    for (const log of all){\n        const key = `${log.transactionHash}-${parseInt(log.logIndex, 16)}`;\n        uniq.set(key, log);\n    }\n    return Array.from(uniq.values());\n}\nfunction decode(log) {\n    try {\n        const parsed = iface.parseLog({\n            topics: log.topics,\n            data: log.data\n        });\n        const [gameNumber, gameId, startedAt, winningPlayer, winningClasses, losingPlayer, losingClasses, gameLength, endReason, gameType, metadata] = parsed.args;\n        return {\n            blockNumber: parseInt(log.blockNumber, 16),\n            txHash: log.transactionHash,\n            logIndex: parseInt(log.logIndex, 16),\n            gameNumber: Number(gameNumber?.toString?.() ?? gameNumber),\n            gameId: String(gameId),\n            startedAt: String(startedAt),\n            winningPlayer: normalizePlayer(String(winningPlayer)),\n            winningClasses: String(winningClasses),\n            losingPlayer: normalizePlayer(String(losingPlayer)),\n            losingClasses: String(losingClasses),\n            gameLength: String(gameLength),\n            endReason: String(endReason),\n            gameType: gameType != null ? String(gameType) : undefined,\n            metadata: metadata != null ? String(metadata) : undefined,\n            network: \"megaeth-testnet-v2\"\n        };\n    } catch  {\n        return null;\n    }\n}\nfunction decodeLegacy(log) {\n    try {\n        const parsed = legacyIface.parseLog({\n            topics: log.topics,\n            data: log.data\n        });\n        const [gameNumber, gameId, startedAt, winningPlayer, winningClasses, losingPlayer, losingClasses, gameLength, endReason] = parsed.args;\n        return {\n            blockNumber: parseInt(log.blockNumber, 16),\n            txHash: log.transactionHash,\n            logIndex: parseInt(log.logIndex, 16),\n            gameNumber: Number(gameNumber?.toString?.() ?? gameNumber),\n            gameId: String(gameId),\n            startedAt: String(startedAt),\n            winningPlayer: normalizePlayer(String(winningPlayer)),\n            winningClasses: String(winningClasses),\n            losingPlayer: normalizePlayer(String(losingPlayer)),\n            losingClasses: String(losingClasses),\n            gameLength: String(gameLength),\n            endReason: String(endReason),\n            network: \"legacy\"\n        };\n    } catch  {\n        return null;\n    }\n}\nfunction decodeLogs(logs, isLegacy = false) {\n    const decoder = isLegacy ? decodeLegacy : decode;\n    return logs.map(decoder).filter(Boolean);\n}\nfunction dedupeRows(rows) {\n    const uniq = new Map();\n    for (const r of rows){\n        const idxOrBlock = typeof r.logIndex === \"number\" && !isNaN(r.logIndex) ? r.logIndex : r.blockNumber;\n        uniq.set(`${r.txHash}:${idxOrBlock}`, r);\n    }\n    return Array.from(uniq.values());\n}\nfunction mergeRows(a, b) {\n    const map = new Map();\n    for (const r of a)map.set(stableRowKey(r), r);\n    for (const r of b)map.set(stableRowKey(r), r);\n    return Array.from(map.values());\n}\nfunction hasMegaRows(entry) {\n    return Boolean(entry?.rows?.some((r)=>r.network === \"megaeth-testnet-v2\"));\n}\nfunction mergeDayEntries(a, b) {\n    if (!a) return b;\n    if (!b) return a;\n    const rows = dedupeRows([\n        ...a.rows,\n        ...b.rows\n    ]).sort(sortByTimestamp);\n    return {\n        fromBlock: Math.min(a.fromBlock, b.fromBlock),\n        toBlock: Math.max(a.toBlock, b.toBlock),\n        rows,\n        lastUpdate: Date.now()\n    };\n}\nasync function ensureMegaRows(entry, dayStartTs, dayEndTs, bounds) {\n    if (hasMegaRows(entry)) return entry;\n    const built = await buildDay(dayStartTs, dayEndTs, bounds);\n    const merged = mergeDayEntries(entry, built.entry);\n    return merged || built.entry;\n}\nfunction parseStartedAtTs(str) {\n    if (!str) return null;\n    // Common on-chain string: \"YYYY-MM-DD HH:mm:ss UTC\"\n    const m = /^([0-9]{4})-([0-9]{2})-([0-9]{2})[ T]([0-9]{2}):([0-9]{2}):([0-9]{2})(?:\\s*(?:UTC|Z))?$/i.exec(str.trim());\n    if (m) {\n        const year = Number(m[1]);\n        const month = Number(m[2]) - 1; // JS months are 0-based\n        const day = Number(m[3]);\n        const hour = Number(m[4]);\n        const minute = Number(m[5]);\n        const second = Number(m[6]);\n        const ms = Date.UTC(year, month, day, hour, minute, second);\n        return Math.floor(ms / 1000);\n    }\n    // Fallback: try to coerce to ISO\n    const iso = str.replace(\" \", \"T\").replace(/\\s*UTC$/i, \"Z\");\n    const ms = Date.parse(iso);\n    if (isNaN(ms)) return null;\n    return Math.floor(ms / 1000);\n}\nfunction sortByTimestamp(a, b) {\n    const tsA = parseStartedAtTs(a.startedAt);\n    const tsB = parseStartedAtTs(b.startedAt);\n    if (tsA !== null && tsB !== null) return tsB - tsA; // newest first\n    if (tsA !== null) return -1; // a has timestamp, b doesn't - a comes first\n    if (tsB !== null) return 1; // b has timestamp, a doesn't - b comes first\n    return b.blockNumber - a.blockNumber; // fallback to blockNumber (newest first)\n}\nfunction filterRowsByTs(rows, startTs, endTs) {\n    return rows.filter((r)=>{\n        const ts = parseStartedAtTs(r.startedAt);\n        if (ts == null) return true;\n        return ts >= startTs && ts <= endTs;\n    });\n}\nfunction stableRowKey(r) {\n    const anyR = r;\n    if (typeof anyR.logIndex === \"number\" && !isNaN(anyR.logIndex)) return `${r.txHash}:${anyR.logIndex}`;\n    if (r.gameId) return `gid:${r.gameId}`;\n    return `${r.txHash}:${r.blockNumber}`;\n}\nasync function buildDay(dayStartTs, dayEndTs, bounds) {\n    const key = Math.floor(dayStartTs / 86400);\n    const safeStart = Math.max(dayStartTs, bounds.earliest.ts);\n    const endTs = Math.min(Math.max(dayEndTs, 0), bounds.latest.ts);\n    const fromBlock = await findBlockAtOrAfter(safeStart, bounds);\n    const toBlock = await findBlockAtOrBefore(endTs, bounds);\n    if (toBlock < fromBlock) return {\n        key,\n        entry: {\n            fromBlock,\n            toBlock,\n            rows: [],\n            lastUpdate: Date.now()\n        }\n    };\n    // Determine which contract to use based on the day start timestamp\n    // For Nov 15 and later, use new contract; before Nov 15, use legacy\n    const isLegacyDay = dayStartTs < NEW_CONTRACT_START_TS;\n    const contract = isLegacyDay ? LEGACY_CONTRACT : CONTRACT;\n    const topic0 = isLegacyDay ? LEGACY_TOPIC0 : TOPIC0;\n    const isLegacy = isLegacyDay;\n    // Safety: For days after Nov 15, ensure we're using the new contract\n    if (dayStartTs >= NEW_CONTRACT_START_TS && contract !== CONTRACT) {\n        // This should never happen, but if it does, use new contract\n        const logs = await getLogsChunked(fromBlock, toBlock, CONTRACT, TOPIC0);\n        const rows = dedupeRows(decodeLogs(logs, false));\n        return {\n            key,\n            entry: {\n                fromBlock,\n                toBlock,\n                rows,\n                lastUpdate: Date.now()\n            }\n        };\n    }\n    try {\n        const logs = await getLogsSingle(fromBlock, toBlock, contract, topic0);\n        const rows = dedupeRows(decodeLogs(logs, isLegacy));\n        return {\n            key,\n            entry: {\n                fromBlock,\n                toBlock,\n                rows,\n                lastUpdate: Date.now()\n            }\n        };\n    } catch  {\n        const logs = await getLogsChunked(fromBlock, toBlock, contract, topic0);\n        const rows = dedupeRows(decodeLogs(logs, isLegacy));\n        return {\n            key,\n            entry: {\n                fromBlock,\n                toBlock,\n                rows,\n                lastUpdate: Date.now()\n            }\n        };\n    }\n}\nasync function extendToday(existing, dayStartTs, dayEndTs, bounds) {\n    const fromBlock = existing.toBlock + 1;\n    const toBlock = await findBlockAtOrBefore(Math.min(Math.max(dayEndTs, 0), bounds.latest.ts), bounds);\n    if (toBlock < fromBlock) return existing;\n    let newLogs = [];\n    try {\n        newLogs = await getLogsSingle(fromBlock, toBlock);\n    } catch  {\n        newLogs = await getLogsChunked(fromBlock, toBlock);\n    }\n    const newRows = newLogs.map(decode).filter(Boolean);\n    const merged = [\n        ...existing.rows,\n        ...newRows\n    ];\n    const uniq = new Map();\n    for (const r of merged){\n        const idxOrBlock = typeof r.logIndex === \"number\" && !isNaN(r.logIndex) ? r.logIndex : r.blockNumber;\n        uniq.set(`${r.txHash}:${idxOrBlock}`, r);\n    }\n    return {\n        fromBlock: existing.fromBlock,\n        toBlock,\n        rows: Array.from(uniq.values()),\n        lastUpdate: Date.now()\n    };\n}\nasync function fetchRangeRowsDirect(startTs, endTs, bounds) {\n    const clampedStart = Math.max(startTs, bounds.earliest.ts);\n    const clampedEnd = Math.min(Math.max(endTs, clampedStart), bounds.latest.ts);\n    if (clampedEnd < clampedStart) return [];\n    // Optimize: only query contracts that have data for this date range\n    const needsLegacy = clampedStart < NEW_CONTRACT_START_TS;\n    const needsNew = clampedEnd >= NEW_CONTRACT_START_TS;\n    const queries = [];\n    if (needsLegacy) {\n        // Query legacy contract for dates before new contract started\n        const legacyEndTs = Math.min(clampedEnd, NEW_CONTRACT_START_TS - 1);\n        const legacyFromBlock = await findBlockAtOrAfter(clampedStart, bounds);\n        const legacyToBlock = await findBlockAtOrBefore(legacyEndTs, bounds);\n        if (legacyToBlock >= legacyFromBlock) {\n            queries.push((async ()=>{\n                try {\n                    const logs = await getLogsSingle(legacyFromBlock, legacyToBlock, LEGACY_CONTRACT, LEGACY_TOPIC0);\n                    return dedupeRows(decodeLogs(logs, true));\n                } catch  {\n                    const logs = await getLogsChunked(legacyFromBlock, legacyToBlock, LEGACY_CONTRACT, LEGACY_TOPIC0);\n                    return dedupeRows(decodeLogs(logs, true));\n                }\n            })());\n        }\n    }\n    if (needsNew) {\n        // Query new contract for dates after it started\n        const newStartTs = Math.max(clampedStart, NEW_CONTRACT_START_TS);\n        const newFromBlock = await findBlockAtOrAfter(newStartTs, bounds);\n        const newToBlock = await findBlockAtOrBefore(clampedEnd, bounds);\n        if (newToBlock >= newFromBlock) {\n            queries.push((async ()=>{\n                try {\n                    // Ensure we're using the correct contract and topic\n                    if (CONTRACT !== \"0x86b6f3856f086cd29462985f7bbff0d55d2b5d53\") {\n                        throw new Error(`Wrong contract address: ${CONTRACT}`);\n                    }\n                    const logs = await getLogsSingle(newFromBlock, newToBlock, CONTRACT, TOPIC0);\n                    const decoded = decodeLogs(logs, false);\n                    const deduped = dedupeRows(decoded);\n                    if (deduped.length === 0 && logs.length > 0) {\n                        console.error(\"Decoded logs but got 0 rows\", {\n                            logsLength: logs.length,\n                            fromBlock: newFromBlock,\n                            toBlock: newToBlock\n                        });\n                    }\n                    return deduped;\n                } catch (err) {\n                    console.error(\"getLogsSingle failed, trying chunked\", {\n                        error: err?.message || String(err),\n                        fromBlock: newFromBlock,\n                        toBlock: newToBlock,\n                        contract: CONTRACT,\n                        topic0: TOPIC0\n                    });\n                    try {\n                        const logs = await getLogsChunked(newFromBlock, newToBlock, CONTRACT, TOPIC0);\n                        const decoded = decodeLogs(logs, false);\n                        const deduped = dedupeRows(decoded);\n                        return deduped;\n                    } catch (chunkErr) {\n                        console.error(\"getLogsChunked also failed\", {\n                            error: chunkErr?.message || String(chunkErr),\n                            fromBlock: newFromBlock,\n                            toBlock: newToBlock\n                        });\n                        return []; // Return empty instead of throwing\n                    }\n                }\n            })());\n        }\n    }\n    if (queries.length === 0) {\n        console.error(\"fetchRangeRowsDirect: No queries to execute\", {\n            startTs,\n            endTs,\n            needsLegacy,\n            needsNew\n        });\n        return [];\n    }\n    // Execute queries in parallel with error handling\n    let results;\n    try {\n        results = await Promise.all(queries);\n    } catch (err) {\n        console.error(\"fetchRangeRowsDirect: Promise.all failed\", {\n            error: err?.message || String(err),\n            startTs,\n            endTs,\n            queriesCount: queries.length\n        });\n        return [];\n    }\n    // Merge all results\n    let allRows = [];\n    for (const rows of results){\n        if (Array.isArray(rows)) {\n            allRows = mergeRows(allRows, rows);\n        } else {\n            console.error(\"fetchRangeRowsDirect: Invalid rows result\", {\n                rows\n            });\n        }\n    }\n    allRows.sort(sortByTimestamp);\n    if (allRows.length === 0 && endTs >= NEW_CONTRACT_START_TS) {\n        console.error(\"fetchRangeRowsDirect: Got 0 rows for new contract range\", {\n            startTs,\n            endTs,\n            needsNew,\n            queriesCount: queries.length,\n            resultsLengths: results.map((r)=>Array.isArray(r) ? r.length : \"invalid\")\n        });\n    }\n    return allRows;\n}\nasync function handler(req, res) {\n    try {\n        const { startTs, endTs, rebuildDay, wantAgg } = req.body || {};\n        // Admin: rebuild a specific day (UTC day index)\n        if (typeof rebuildDay === \"number\" && rebuildDay >= 0) {\n            const earliest = await getEarliest();\n            const latest = await getLatest();\n            const bounds = {\n                earliest,\n                latest\n            };\n            const start = rebuildDay * 86400;\n            const end = start + 86399;\n            const built = await buildDay(start, end, bounds);\n            remember(built.key, built.entry);\n            await kvSetDay(built.key, built.entry);\n            return sendJson(res, 200, {\n                ok: true,\n                rebuilt: built.key,\n                fromBlock: built.entry.fromBlock,\n                toBlock: built.entry.toBlock,\n                rows: built.entry.rows.length\n            });\n        }\n        const earliest = await getEarliest();\n        const latest = await getLatest();\n        const bounds = {\n            earliest,\n            latest\n        };\n        const sTs = typeof startTs === \"number\" && startTs > 0 ? startTs : earliest.ts;\n        const eTs = typeof endTs === \"number\" && endTs > 0 ? endTs : latest.ts;\n        if (eTs < sTs) return sendJson(res, 200, {\n            ok: true,\n            rows: []\n        });\n        let resultRows = [];\n        if (!KV_ENV_PRESENT) {\n            resultRows = await fetchRangeRowsDirect(sTs, eTs, bounds);\n        } else {\n            // SIMPLIFIED APPROACH: Split query into two parts\n            // 1. Days before Nov 15: use cache (fast, proven to work)\n            // 2. Days after Nov 14: ALWAYS fetch directly using fetchRangeRowsDirect (guaranteed to work)\n            const beforeNewContractEnd = Math.min(eTs, NEW_CONTRACT_START_TS - 1);\n            const afterNewContractStart = Math.max(sTs, NEW_CONTRACT_START_TS);\n            // Fetch days before Nov 15 using cache\n            // IMPORTANT: Skip days after Nov 14 - they're fetched directly below\n            if (sTs < NEW_CONTRACT_START_TS && beforeNewContractEnd >= sTs) {\n                const startDay = Math.floor(sTs / 86400);\n                const endDay = Math.floor(beforeNewContractEnd / 86400);\n                const todayDay = Math.floor(latest.ts / 86400);\n                const newContractStartDay = Math.floor(NEW_CONTRACT_START_TS / 86400);\n                const dayRanges = [];\n                for(let d = startDay; d <= endDay; d++){\n                    // Skip days after Nov 14 - they're fetched directly, not through cache\n                    if (d >= newContractStartDay) continue;\n                    const dayStart = d * 86400;\n                    const dayEnd = dayStart + 86399;\n                    dayRanges.push({\n                        key: d,\n                        start: Math.max(dayStart, sTs),\n                        end: Math.min(dayEnd, beforeNewContractEnd)\n                    });\n                }\n                const CONC = Math.max(1, DAY_RANGE_CONCURRENCY);\n                for(let i = 0; i < dayRanges.length; i += CONC){\n                    const slice = dayRanges.slice(i, i + CONC).map(async (r)=>{\n                        const isHistorical = r.key < todayDay;\n                        const dayStartTs = r.key * 86400;\n                        const dayEndTs = dayStartTs + 86399;\n                        // Days after Nov 14 need new contract data\n                        const needsNewContract = dayStartTs >= NEW_CONTRACT_START_TS;\n                        // For days after Nov 14, always use full day range when rebuilding\n                        const rebuildStart = needsNewContract ? dayStartTs : r.start;\n                        const rebuildEnd = needsNewContract ? dayEndTs : r.end;\n                        // For days after Nov 14: ensure we have cached data from new contract\n                        if (needsNewContract && isHistorical) {\n                            // Check cache first - but be aggressive: if cache is empty or doesn't have mega rows, always fetch fresh\n                            // 1) Try in-memory cache\n                            const mem = dayCache.get(memKey(r.key));\n                            if (mem && hasMegaRows(mem) && mem.rows.length > 0) {\n                                // Cache has new contract data with actual rows - use it\n                                resultRows.push(...mem.rows);\n                                return;\n                            }\n                            // 2) Try persistent KV cache\n                            const fromKv = await kvGetDay(r.key);\n                            if (fromKv && hasMegaRows(fromKv) && fromKv.rows.length > 0) {\n                                // KV cache has new contract data with actual rows - use it and load into memory\n                                remember(r.key, fromKv);\n                                resultRows.push(...fromKv.rows);\n                                return;\n                            }\n                            // 3) Cache doesn't exist, is empty, or doesn't have new contract data - ALWAYS fetch fresh using EXACT same method as extendToday\n                            // This is the proven method that works for today\n                            const fromBlock = await findBlockAtOrAfter(rebuildStart, bounds);\n                            const toBlock = await findBlockAtOrBefore(rebuildEnd, bounds);\n                            if (toBlock < fromBlock) {\n                                // No blocks in range - don't cache, just return empty (will retry next time)\n                                return;\n                            }\n                            // Use EXACT same method as extendToday: getLogsSingle/getLogsChunked with defaults (CONTRACT/TOPIC0)\n                            let newLogs = [];\n                            try {\n                                newLogs = await getLogsSingle(fromBlock, toBlock);\n                            } catch  {\n                                newLogs = await getLogsChunked(fromBlock, toBlock);\n                            }\n                            // Use EXACT same decode method as extendToday\n                            const newRows = newLogs.map(decode).filter(Boolean);\n                            // Dedupe same way as extendToday\n                            const uniq = new Map();\n                            for (const r of newRows){\n                                const idxOrBlock = typeof r.logIndex === \"number\" && !isNaN(r.logIndex) ? r.logIndex : r.blockNumber;\n                                uniq.set(`${r.txHash}:${idxOrBlock}`, r);\n                            }\n                            const fetchedRows = Array.from(uniq.values());\n                            const entry = {\n                                fromBlock,\n                                toBlock,\n                                rows: fetchedRows,\n                                lastUpdate: Date.now()\n                            };\n                            // Only cache if we got data - don't cache empty results for days after Nov 14\n                            // This ensures we keep retrying until we get the data\n                            if (fetchedRows.length > 0) {\n                                remember(r.key, entry);\n                                await kvSetDay(r.key, entry);\n                            }\n                            resultRows.push(...fetchedRows);\n                            return;\n                        }\n                        // For days before Nov 15 or today: use existing logic\n                        // 1) Try in-memory first (fast)\n                        const mem = dayCache.get(memKey(r.key));\n                        if (mem) {\n                            if (isHistorical) {\n                                // Use cache as-is\n                                resultRows.push(...mem.rows);\n                                return;\n                            } else {\n                                // Today: extend with latest data\n                                const updated = await extendToday(mem, r.start, r.end, bounds);\n                                remember(r.key, updated);\n                                await kvSetDay(r.key, updated);\n                                resultRows.push(...updated.rows);\n                                return;\n                            }\n                        }\n                        // 2) Try persistent KV\n                        const fromKv = await kvGetDay(r.key);\n                        if (fromKv) {\n                            if (isHistorical) {\n                                // Use cache as-is, load into memory for next time\n                                remember(r.key, fromKv);\n                                resultRows.push(...fromKv.rows);\n                                return;\n                            } else {\n                                // Today: extend with latest data\n                                const updated = await extendToday(fromKv, r.start, r.end, bounds);\n                                remember(r.key, updated);\n                                await kvSetDay(r.key, updated);\n                                resultRows.push(...updated.rows);\n                                return;\n                            }\n                        }\n                        // 3) Build fresh and persist\n                        const built = await buildDay(rebuildStart, rebuildEnd, bounds);\n                        remember(built.key, built.entry);\n                        await kvSetDay(built.key, built.entry);\n                        resultRows.push(...built.entry.rows);\n                    });\n                    await Promise.all(slice);\n                }\n            }\n            // Fetch days after Nov 14: fetch day-by-day to avoid block range limits, then cache\n            if (eTs >= NEW_CONTRACT_START_TS) {\n                const todayDay = Math.floor(latest.ts / 86400);\n                const todayStartTs = todayDay * 86400;\n                const fetchEnd = Math.min(eTs, todayStartTs - 1); // Exclude today\n                if (fetchEnd >= afterNewContractStart) {\n                    const newContractStartDay = Math.floor(afterNewContractStart / 86400);\n                    const newContractEndDay = Math.floor(fetchEnd / 86400);\n                    // Fetch day-by-day in parallel (but limit concurrency to avoid overwhelming RPC)\n                    const CONC = Math.min(5, newContractEndDay - newContractStartDay + 1);\n                    for(let i = 0; i <= newContractEndDay - newContractStartDay; i += CONC){\n                        const slice = [];\n                        for(let j = 0; j < CONC && newContractStartDay + i + j <= newContractEndDay; j++){\n                            const d = newContractStartDay + i + j;\n                            const dayStartTs = d * 86400;\n                            const dayEndTs = dayStartTs + 86399;\n                            const dayStart = Math.max(dayStartTs, afterNewContractStart);\n                            const dayEnd = Math.min(dayEndTs, fetchEnd);\n                            slice.push((async ()=>{\n                                // Check cache first\n                                let cached = null;\n                                const mem = dayCache.get(memKey(d));\n                                if (mem && hasMegaRows(mem) && mem.rows.length > 0) {\n                                    return mem.rows;\n                                }\n                                const fromKv = await kvGetDay(d);\n                                if (fromKv && hasMegaRows(fromKv) && fromKv.rows.length > 0) {\n                                    remember(d, fromKv);\n                                    return fromKv.rows;\n                                }\n                                // Not in cache - fetch this day\n                                try {\n                                    const fetchedRows = await fetchRangeRowsDirect(dayStart, dayEnd, bounds);\n                                    // Cache the results\n                                    if (fetchedRows.length > 0) {\n                                        let fromBlock;\n                                        let toBlock;\n                                        fromBlock = Math.min(...fetchedRows.map((r)=>r.blockNumber));\n                                        toBlock = Math.max(...fetchedRows.map((r)=>r.blockNumber));\n                                        const entry = {\n                                            fromBlock,\n                                            toBlock,\n                                            rows: fetchedRows,\n                                            lastUpdate: Date.now()\n                                        };\n                                        remember(d, entry);\n                                        await kvSetDay(d, entry);\n                                    }\n                                    return fetchedRows;\n                                } catch (err) {\n                                    console.error(`Failed to fetch day ${d}`, {\n                                        error: err?.message || String(err),\n                                        dayStart,\n                                        dayEnd\n                                    });\n                                    return [];\n                                }\n                            })());\n                        }\n                        const dayResults = await Promise.all(slice);\n                        for (const rows of dayResults){\n                            resultRows = mergeRows(resultRows, rows);\n                        }\n                    }\n                }\n            }\n        }\n        // Only do live fetch for today's data (to get latest matches), skip for historical dates\n        const todayDay = Math.floor(latest.ts / 86400);\n        const endDay = Math.floor(eTs / 86400);\n        if (endDay >= todayDay) {\n            // Request includes today - fetch live data for today only\n            const todayStartTs = todayDay * 86400;\n            const liveStartTs = Math.max(sTs, todayStartTs);\n            if (liveStartTs <= eTs) {\n                const liveRows = await fetchRangeRowsDirect(liveStartTs, eTs, bounds);\n                resultRows = mergeRows(resultRows, liveRows);\n            }\n        }\n        resultRows.sort(sortByTimestamp);\n        // First constrain precisely to the requested [sTs, eTs] window (even if cached full days were used)\n        const windowed = filterRowsByTs(resultRows, sTs, eTs);\n        // Final defensive pass: dedupe across days and cache formats\n        const byKey = new Map();\n        for (const r of windowed)byKey.set(stableRowKey(r), r);\n        const out = Array.from(byKey.values());\n        out.sort(sortByTimestamp);\n        if (wantAgg) {\n            const agg = computeAgg(out);\n            return sendJson(res, 200, {\n                ok: true,\n                rows: out,\n                aggByClass: agg.byClass,\n                aggLastUpdate: agg.lastUpdate\n            });\n        }\n        sendJson(res, 200, {\n            ok: true,\n            rows: out\n        });\n    } catch (e) {\n        sendJson(res, 200, {\n            ok: false,\n            error: e?.message || String(e)\n        });\n    }\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LElBQUlILFVBQVU7WUFBQztRQUMxRztRQUNBaUIsU0FBU0MsS0FBSyxLQUFLO1lBQUV3QixJQUFJO1lBQU10RCxNQUFNNE87UUFBSTtJQUMzQyxFQUFFLE9BQU83SyxHQUFPO1FBQ2RsQyxTQUFTQyxLQUFLLEtBQUs7WUFBRXdCLElBQUk7WUFBT08sT0FBT0UsR0FBR0QsV0FBV2lFLE9BQU9oRTtRQUFHO0lBQ2pFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zaG93ZG93bi13aW5yYXRlLy4vcGFnZXMvYXBpL2V0aC50cz83MzY5Il0sInNvdXJjZXNDb250ZW50IjpbIlxuaW1wb3J0IHR5cGUgeyBOZXh0QXBpUmVxdWVzdCwgTmV4dEFwaVJlc3BvbnNlIH0gZnJvbSAnbmV4dCc7XG5pbXBvcnQgeyBJbnRlcmZhY2UgfSBmcm9tICdldGhlcnMnO1xuaW1wb3J0IHsgZ3ppcFN5bmMgfSBmcm9tICd6bGliJztcblxuY29uc3QgUlBDID0gcHJvY2Vzcy5lbnYuUlBDX1VSTCB8fCAnaHR0cHM6Ly90aW1vdGh5Lm1lZ2FldGguY29tL21hZmlhL3JwYy9sMXo0eDdjMHYzYjZuOW0yYTVzOGQxZjRnN2gwajNrNnE5dzJlNXI4JztcbmNvbnN0IENPTlRSQUNUID0gKHByb2Nlc3MuZW52LkNPTlRSQUNUX0FERFJFU1MgfHwgJzB4ODZiNmYzODU2ZjA4NmNkMjk0NjI5ODVmN2JiZmYwZDU1ZDJiNWQ1MycpLnRvTG93ZXJDYXNlKCk7XG5jb25zdCBMRUdBQ1lfQ09OVFJBQ1QgPSAnMHhhZTJhZmU0ZDE5MjEyN2U2NjE3Y2ZhNjM4YTk0Mzg0YjUzZmFjZWMxJy50b0xvd2VyQ2FzZSgpO1xuY29uc3QgTEVHQUNZX1RPUElDMCA9ICcweGNjYzkzOGFiYzAxMzQ0NDEzZWZlZTM2YjVkNDg0Y2VkZDNiZjRjZTkzYjQ5NmU4MDIxYmEwMjFmZWQ5ZTI3MjUnO1xuY29uc3QgVE9QSUMwID0gJzB4OTUzNDBlY2YyZmQxYzFkYTgyN2Y0Y2YwMTBkMDcyNmM2NWMyZTA1Njg0YTQ5MmM0ZWVhYTZhYzFiOTFiYWJmMCc7XG4vLyBOZXcgY29udHJhY3Qgc3RhcnRlZCBhcm91bmQgTm92IDE1LCAyMDI1IDAwOjAwOjAwIFVUQyAobGVnYWN5IGNvbnRyYWN0IHN0b3BwZWQgYXJvdW5kIHRoZW4pXG5jb25zdCBORVdfQ09OVFJBQ1RfU1RBUlRfVFMgPSBNYXRoLmZsb29yKG5ldyBEYXRlKCcyMDI1LTExLTE1VDAwOjAwOjAwWicpLmdldFRpbWUoKSAvIDEwMDApO1xuY29uc3QgTUFYX1NQQU4gPSAxMDBfMDAwO1xuY29uc3QgTUFYX0RBWVNfQ0FDSEUgPSAxMjA7XG5jb25zdCBSUENfUkVUUllfQVRURU1QVFMgPSA2O1xuY29uc3QgUlBDX0JBU0VfREVMQVlfTVMgPSA4MDA7XG5jb25zdCBEQVlfUkFOR0VfQ09OQ1VSUkVOQ1kgPSAxMDsgLy8gSW5jcmVhc2VkIGZvciBmYXN0ZXIgS1YgY2FjaGUgcmV0cmlldmFsXG5jb25zdCBMT0dfUkFOR0VfQ09OQ1VSUkVOQ1kgPSAyO1xuXG50eXBlIFJvdyA9IHtcbiAgYmxvY2tOdW1iZXI6IG51bWJlcjtcbiAgdHhIYXNoOiBzdHJpbmc7XG4gIGxvZ0luZGV4OiBudW1iZXI7XG4gIGdhbWVOdW1iZXI6IG51bWJlcjtcbiAgZ2FtZUlkOiBzdHJpbmc7XG4gIHN0YXJ0ZWRBdDogc3RyaW5nO1xuICB3aW5uaW5nUGxheWVyOiBzdHJpbmc7XG4gIHdpbm5pbmdDbGFzc2VzOiBzdHJpbmc7XG4gIGxvc2luZ1BsYXllcjogc3RyaW5nO1xuICBsb3NpbmdDbGFzc2VzOiBzdHJpbmc7XG4gIGdhbWVMZW5ndGg6IHN0cmluZztcbiAgZW5kUmVhc29uOiBzdHJpbmc7XG4gIGdhbWVUeXBlPzogc3RyaW5nO1xuICBtZXRhZGF0YT86IHN0cmluZztcbiAgbmV0d29yaz86ICdsZWdhY3knIHwgJ21lZ2FldGgtdGVzdG5ldC12Mic7XG59O1xudHlwZSBEYXlFbnRyeSA9IHsgZnJvbUJsb2NrOiBudW1iZXI7IHRvQmxvY2s6IG51bWJlcjsgcm93czogUm93W107IGxhc3RVcGRhdGU6IG51bWJlciB9O1xudHlwZSBEYXlBZ2cgPSB7IGJ5Q2xhc3M6IFJlY29yZDxzdHJpbmcsIHsgd2luczogbnVtYmVyOyBsb3NzZXM6IG51bWJlcjsgdG90YWw6IG51bWJlciB9PjsgbGFzdFVwZGF0ZTogbnVtYmVyIH07XG50eXBlIEJsb2NrSW5mbyA9IHsgbnVtOiBudW1iZXI7IHRzOiBudW1iZXIgfTtcbnR5cGUgQmxvY2tCb3VuZHMgPSB7IGVhcmxpZXN0OiBCbG9ja0luZm87IGxhdGVzdDogQmxvY2tJbmZvIH07XG5cbmNvbnN0IENBQ0hFX05BTUVTUEFDRSA9IChwcm9jZXNzLmVudi5DQUNIRV9OQU1FU1BBQ0UgfHwgYCR7Q09OVFJBQ1R9OiR7VE9QSUMwfWApLnRvTG93ZXJDYXNlKCk7XG5mdW5jdGlvbiBtZW1LZXkoZGF5SW5kZXg6IG51bWJlcikgeyByZXR1cm4gYCR7Q0FDSEVfTkFNRVNQQUNFfToke2RheUluZGV4fWA7IH1cbmNvbnN0IGRheUNhY2hlID0gbmV3IE1hcDxzdHJpbmcsIERheUVudHJ5PigpO1xuY29uc3QgZGF5T3JkZXI6IHN0cmluZ1tdID0gW107XG5mdW5jdGlvbiByZW1lbWJlcihkYXlJbmRleDogbnVtYmVyLCBlbnRyeTogRGF5RW50cnkpIHtcbiAgY29uc3Qga2V5ID0gbWVtS2V5KGRheUluZGV4KTtcbiAgaWYgKCFkYXlDYWNoZS5oYXMoa2V5KSkgZGF5T3JkZXIucHVzaChrZXkpO1xuICBkYXlDYWNoZS5zZXQoa2V5LCBlbnRyeSk7XG4gIHdoaWxlIChkYXlPcmRlci5sZW5ndGggPiBNQVhfREFZU19DQUNIRSkge1xuICAgIGNvbnN0IGV2aWN0ID0gZGF5T3JkZXIuc2hpZnQoKTtcbiAgICBpZiAoZXZpY3QgIT09IHVuZGVmaW5lZCkgZGF5Q2FjaGUuZGVsZXRlKGV2aWN0KTtcbiAgfVxufVxuZnVuY3Rpb24gZGF5SW5kZXhGcm9tVHModHM6IG51bWJlcikgeyByZXR1cm4gTWF0aC5mbG9vcih0cyAvIDg2NDAwKTsgfVxuZnVuY3Rpb24gY2xhbXAobjogbnVtYmVyLCBhOiBudW1iZXIsIGI6IG51bWJlcikgeyByZXR1cm4gTWF0aC5tYXgoYSwgTWF0aC5taW4oYiwgbikpOyB9XG5cbi8vIE9wdGlvbmFsIHBlcnNpc3RlbnQgY2FjaGUgKFZlcmNlbCBLViBvciBVcHN0YXNoIGZvciBSZWRpcyB2aWEgUkVTVCkuIEZhbGxzIGJhY2sgdG8gaW4tbWVtb3J5IG9ubHkgaWYgbm90IGNvbmZpZ3VyZWQuXG4vLyBXZSBsYXppbHkgaW1wb3J0ICdAdmVyY2VsL2t2JyBhZnRlciBub3JtYWxpemluZyBlbnZzIHNvIGl0IHdvcmtzIHdpdGggZWl0aGVyIEtWXyogb3IgVVBTVEFTSF8qLlxuY29uc3QgS1ZfRU5WX1BSRVNFTlQgPSAhIShwcm9jZXNzLmVudi5LVl9SRVNUX0FQSV9VUkwgfHwgcHJvY2Vzcy5lbnYuVVBTVEFTSF9SRURJU19SRVNUX1VSTCk7XG5mdW5jdGlvbiBrdktleShkYXlJbmRleDogbnVtYmVyKSB7IHJldHVybiBgJHtDQUNIRV9OQU1FU1BBQ0V9OmRheToke2RheUluZGV4fWA7IH1cbmZ1bmN0aW9uIGt2QWdnS2V5KGRheUluZGV4OiBudW1iZXIpIHsgcmV0dXJuIGAke0NBQ0hFX05BTUVTUEFDRX06ZGF5QWdnOiR7ZGF5SW5kZXh9YDsgfVxuZnVuY3Rpb24gbGVnYWN5S3ZLZXkoZGF5SW5kZXg6IG51bWJlcikgeyByZXR1cm4gYGRheToke2RheUluZGV4fWA7IH1cbmZ1bmN0aW9uIGxlZ2FjeUt2QWdnS2V5KGRheUluZGV4OiBudW1iZXIpIHsgcmV0dXJuIGBkYXlBZ2c6JHtkYXlJbmRleH1gOyB9XG5sZXQgX2t2Q2xpZW50OiBhbnkgfCBudWxsID0gbnVsbDtcbmFzeW5jIGZ1bmN0aW9uIGdldEt2KCkge1xuICBpZiAoIUtWX0VOVl9QUkVTRU5UKSByZXR1cm4gbnVsbDtcbiAgLy8gTm9ybWFsaXplIFVwc3Rhc2gg4oaSIFZlcmNlbCBLViBlbnYgbmFtZXMgaWYgbmVlZGVkXG4gIGlmICghcHJvY2Vzcy5lbnYuS1ZfUkVTVF9BUElfVVJMICYmIHByb2Nlc3MuZW52LlVQU1RBU0hfUkVESVNfUkVTVF9VUkwpIHtcbiAgICBwcm9jZXNzLmVudi5LVl9SRVNUX0FQSV9VUkwgPSBwcm9jZXNzLmVudi5VUFNUQVNIX1JFRElTX1JFU1RfVVJMO1xuICB9XG4gIGlmICghcHJvY2Vzcy5lbnYuS1ZfUkVTVF9BUElfVE9LRU4gJiYgcHJvY2Vzcy5lbnYuVVBTVEFTSF9SRURJU19SRVNUX1RPS0VOKSB7XG4gICAgcHJvY2Vzcy5lbnYuS1ZfUkVTVF9BUElfVE9LRU4gPSBwcm9jZXNzLmVudi5VUFNUQVNIX1JFRElTX1JFU1RfVE9LRU47XG4gIH1cbiAgaWYgKCFfa3ZDbGllbnQpIHtcbiAgICBjb25zdCBtb2QgPSBhd2FpdCBpbXBvcnQoJ0B2ZXJjZWwva3YnKTtcbiAgICBfa3ZDbGllbnQgPSBtb2Qua3Y7XG4gIH1cbiAgcmV0dXJuIF9rdkNsaWVudDtcbn1cbmFzeW5jIGZ1bmN0aW9uIGt2R2V0RGF5KGRheUluZGV4OiBudW1iZXIpOiBQcm9taXNlPERheUVudHJ5IHwgbnVsbD4ge1xuICB0cnkge1xuICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IGdldEt2KCk7XG4gICAgaWYgKCFjbGllbnQpIHJldHVybiBudWxsO1xuICAgIGNvbnN0IGRheVN0YXJ0VHMgPSBkYXlJbmRleCAqIDg2NDAwO1xuICAgIGNvbnN0IG5lZWRzTmV3Q29udHJhY3QgPSBkYXlTdGFydFRzID49IE5FV19DT05UUkFDVF9TVEFSVF9UUztcbiAgICBcbiAgICBpZiAobmVlZHNOZXdDb250cmFjdCkge1xuICAgICAgLy8gRm9yIGRheXMgYWZ0ZXIgTm92IDE1LCBPTkxZIHVzZSBuZXcgY29udHJhY3QgY2FjaGUgLSBuZXZlciBmYWxsIGJhY2sgdG8gbGVnYWN5XG4gICAgICBjb25zdCBuZXdLZXkgPSBhd2FpdCBjbGllbnQuZ2V0KGt2S2V5KGRheUluZGV4KSk7XG4gICAgICByZXR1cm4gbmV3S2V5IGFzIERheUVudHJ5IHwgbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRm9yIGRheXMgYmVmb3JlIE5vdiAxNSwgdHJ5IGJvdGgga2V5cyAobGVnYWN5IG1pZ2h0IGhhdmUgZGF0YSlcbiAgICAgIGNvbnN0IFtuZXdLZXksIGxlZ2FjeUtleV0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgIGNsaWVudC5nZXQoa3ZLZXkoZGF5SW5kZXgpKSxcbiAgICAgICAgY2xpZW50LmdldChsZWdhY3lLdktleShkYXlJbmRleCkpLFxuICAgICAgXSk7XG4gICAgICByZXR1cm4gKG5ld0tleSB8fCBsZWdhY3lLZXkpIGFzIERheUVudHJ5IHwgbnVsbDtcbiAgICB9XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5mdW5jdGlvbiBjb21wdXRlQWdnKHJvd3M6IFJvd1tdKTogRGF5QWdnIHtcbiAgY29uc3QgbWFwOiBSZWNvcmQ8c3RyaW5nLCB7IHdpbnM6IG51bWJlcjsgbG9zc2VzOiBudW1iZXI7IHRvdGFsOiBudW1iZXIgfT4gPSB7fTtcbiAgZm9yIChjb25zdCByIG9mIHJvd3MpIHtcbiAgICBjb25zdCB3ID0gKHIud2lubmluZ0NsYXNzZXMgfHwgJycpLnRyaW0oKTtcbiAgICBjb25zdCBsID0gKHIubG9zaW5nQ2xhc3NlcyB8fCAnJykudHJpbSgpO1xuICAgIGlmICh3KSB7IGlmICghbWFwW3ddKSBtYXBbd10gPSB7IHdpbnM6IDAsIGxvc3NlczogMCwgdG90YWw6IDAgfTsgbWFwW3ddLndpbnMgKz0gMTsgbWFwW3ddLnRvdGFsICs9IDE7IH1cbiAgICBpZiAobCkgeyBpZiAoIW1hcFtsXSkgbWFwW2xdID0geyB3aW5zOiAwLCBsb3NzZXM6IDAsIHRvdGFsOiAwIH07IG1hcFtsXS5sb3NzZXMgKz0gMTsgbWFwW2xdLnRvdGFsICs9IDE7IH1cbiAgfVxuICByZXR1cm4geyBieUNsYXNzOiBtYXAsIGxhc3RVcGRhdGU6IERhdGUubm93KCkgfTtcbn1cblxuYXN5bmMgZnVuY3Rpb24ga3ZTZXREYXkoZGF5SW5kZXg6IG51bWJlciwgZW50cnk6IERheUVudHJ5KTogUHJvbWlzZTx2b2lkPiB7XG4gIHRyeSB7XG4gICAgY29uc3QgY2xpZW50ID0gYXdhaXQgZ2V0S3YoKTtcbiAgICBpZiAoIWNsaWVudCkgcmV0dXJuO1xuICAgIGF3YWl0IGNsaWVudC5zZXQoa3ZLZXkoZGF5SW5kZXgpLCBlbnRyeSk7XG4gICAgLy8gQWxzbyBwZXJzaXN0IGFnZ3JlZ2F0ZXMgZm9yIGZhc3Qgc3RhdHNcbiAgICBjb25zdCBhZ2cgPSBjb21wdXRlQWdnKGVudHJ5LnJvd3MpO1xuICAgIGF3YWl0IGNsaWVudC5zZXQoa3ZBZ2dLZXkoZGF5SW5kZXgpLCBhZ2cpO1xuICB9IGNhdGNoIHt9XG59XG5cbmNvbnN0IGlmYWNlID0gbmV3IEludGVyZmFjZShbXG4gICdldmVudCBHYW1lUmVzdWx0RXZlbnQodWludDI1NiBnYW1lTnVtYmVyLCBzdHJpbmcgZ2FtZUlkLCBzdHJpbmcgc3RhcnRlZEF0LCBzdHJpbmcgd2lubmluZ1BsYXllciwgc3RyaW5nIHdpbm5pbmdDbGFzc2VzLCBzdHJpbmcgbG9zaW5nUGxheWVyLCBzdHJpbmcgbG9zaW5nQ2xhc3Nlcywgc3RyaW5nIGdhbWVMZW5ndGgsIHN0cmluZyBlbmRSZWFzb24sIHN0cmluZyBnYW1lVHlwZSwgc3RyaW5nIG1ldGFkYXRhKScsXG5dKTtcbmNvbnN0IGxlZ2FjeUlmYWNlID0gbmV3IEludGVyZmFjZShbXG4gICdldmVudCBHYW1lUmVzdWx0RXZlbnQodWludDI1NiBnYW1lTnVtYmVyLCBzdHJpbmcgZ2FtZUlkLCBzdHJpbmcgc3RhcnRlZEF0LCBzdHJpbmcgd2lubmluZ1BsYXllciwgc3RyaW5nIHdpbm5pbmdDbGFzc2VzLCBzdHJpbmcgbG9zaW5nUGxheWVyLCBzdHJpbmcgbG9zaW5nQ2xhc3Nlcywgc3RyaW5nIGdhbWVMZW5ndGgsIHN0cmluZyBlbmRSZWFzb24pJyxcbl0pO1xuXG5mdW5jdGlvbiB0b0hleChuOiBudW1iZXIpIHsgcmV0dXJuICcweCcgKyBuLnRvU3RyaW5nKDE2KTsgfVxuZnVuY3Rpb24gc2xlZXAobXM6IG51bWJlcikgeyByZXR1cm4gbmV3IFByb21pc2Uocj0+c2V0VGltZW91dChyLCBtcykpOyB9XG5mdW5jdGlvbiBub3JtYWxpemVQbGF5ZXIocmF3OiBzdHJpbmcpOiBzdHJpbmcge1xuICBjb25zdCB2YWwgPSAocmF3IHx8ICcnKS50cmltKCk7XG4gIGNvbnN0IGlkeCA9IHZhbC5pbmRleE9mKCcjJyk7XG4gIHJldHVybiBpZHggPT09IC0xID8gdmFsIDogdmFsLnNsaWNlKDAsIGlkeCk7XG59XG5mdW5jdGlvbiBzZW5kSnNvbihyZXM6IE5leHRBcGlSZXNwb25zZSwgc3RhdHVzOiBudW1iZXIsIHBheWxvYWQ6IGFueSkge1xuICBjb25zdCBqc29uID0gSlNPTi5zdHJpbmdpZnkocGF5bG9hZCk7XG4gIGNvbnN0IGd6ID0gZ3ppcFN5bmMoanNvbik7XG4gIHJlcy5zZXRIZWFkZXIoJ0NvbnRlbnQtVHlwZScsICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gIHJlcy5zZXRIZWFkZXIoJ0NvbnRlbnQtRW5jb2RpbmcnLCAnZ3ppcCcpO1xuICByZXMuc3RhdHVzKHN0YXR1cykuc2VuZChneik7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHJwYyhib2R5OiBhbnksIGF0dGVtcHRzID0gUlBDX1JFVFJZX0FUVEVNUFRTLCBiYXNlRGVsYXkgPSBSUENfQkFTRV9ERUxBWV9NUykge1xuICBsZXQgbGFzdEVycjogYW55ID0gbnVsbDtcbiAgZm9yIChsZXQgaT0wO2k8YXR0ZW1wdHM7aSsrKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKFJQQywgeyBtZXRob2Q6ICdQT1NUJywgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpIH0pO1xuICAgICAgaWYgKHJlcy5zdGF0dXMgPT09IDQyOSB8fCByZXMuc3RhdHVzID09PSA1MDMpIHtcbiAgICAgICAgbGFzdEVyciA9IG5ldyBFcnJvcignUlBDIEhUVFAgJyArIHJlcy5zdGF0dXMpO1xuICAgICAgICBjb25zdCByZXRyeUFmdGVyID0gTnVtYmVyKHJlcy5oZWFkZXJzLmdldCgncmV0cnktYWZ0ZXInKSk7XG4gICAgICAgIGNvbnN0IHdhaXQgPSByZXRyeUFmdGVyID4gMCA/IHJldHJ5QWZ0ZXIgKiAxMDAwIDogTWF0aC5yb3VuZChiYXNlRGVsYXkgKiBNYXRoLnBvdygxLjgsIGkpKTtcbiAgICAgICAgYXdhaXQgc2xlZXAod2FpdCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKCFyZXMub2spIHRocm93IG5ldyBFcnJvcignUlBDIEhUVFAgJyArIHJlcy5zdGF0dXMpO1xuICAgICAgY29uc3QgaiA9IGF3YWl0IHJlcy5qc29uKCk7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShqKSkge1xuICAgICAgICBjb25zdCBiYWQgPSBqLmZpbmQoKHg6YW55KT0+eCAmJiB4LmVycm9yKTtcbiAgICAgICAgaWYgKGJhZCkgdGhyb3cgbmV3IEVycm9yKGJhZC5lcnJvcj8ubWVzc2FnZSB8fCAnUlBDIGJhdGNoIGVycm9yJyk7XG4gICAgICB9IGVsc2UgaWYgKGogJiYgai5lcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3Ioai5lcnJvcj8ubWVzc2FnZSB8fCAnUlBDIGVycm9yJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gajtcbiAgICB9IGNhdGNoIChlOmFueSkge1xuICAgICAgbGFzdEVyciA9IGU7XG4gICAgICBhd2FpdCBzbGVlcChNYXRoLnJvdW5kKGJhc2VEZWxheSAqIE1hdGgucG93KDEuNiwgaSkpKTtcbiAgICB9XG4gIH1cbiAgdGhyb3cgbGFzdEVyciB8fCBuZXcgRXJyb3IoJ1JQQyBmYWlsZWQgYWZ0ZXIgcmV0cmllcycpO1xufVxuXG5hc3luYyBmdW5jdGlvbiBnZXRCbG9ja0J5VGFnKHRhZzogc3RyaW5nKTogUHJvbWlzZTx7IG51bTpudW1iZXI7IHRzOm51bWJlciB9PiB7XG4gIGNvbnN0IGogPSBhd2FpdCBycGMoeyBqc29ucnBjOiAnMi4wJywgaWQ6IDEsIG1ldGhvZDogJ2V0aF9nZXRCbG9ja0J5TnVtYmVyJywgcGFyYW1zOiBbdGFnLCBmYWxzZV0gfSk7XG4gIGNvbnN0IGJsayA9IGo/LnJlc3VsdDtcbiAgaWYgKCFibGspIHRocm93IG5ldyBFcnJvcignQmxvY2sgbm90IGZvdW5kJyk7XG4gIHJldHVybiB7IG51bTogcGFyc2VJbnQoYmxrLm51bWJlciwgMTYpLCB0czogcGFyc2VJbnQoYmxrLnRpbWVzdGFtcCwgMTYpIH07XG59XG5hc3luYyBmdW5jdGlvbiBnZXRCbG9ja0J5TnVtYmVyKG46IG51bWJlcikgeyByZXR1cm4gZ2V0QmxvY2tCeVRhZyh0b0hleChuKSk7IH1cbmFzeW5jIGZ1bmN0aW9uIGdldEVhcmxpZXN0KCkgeyByZXR1cm4gZ2V0QmxvY2tCeVRhZygnZWFybGllc3QnKTsgfVxuYXN5bmMgZnVuY3Rpb24gZ2V0TGF0ZXN0KCkgeyByZXR1cm4gZ2V0QmxvY2tCeVRhZygnbGF0ZXN0Jyk7IH1cblxuYXN5bmMgZnVuY3Rpb24gZmluZEJsb2NrQXRPckFmdGVyKHRhcmdldFRzOiBudW1iZXIsIGJvdW5kcz86IEJsb2NrQm91bmRzKTogUHJvbWlzZTxudW1iZXI+IHtcbiAgY29uc3QgZWFybGllc3QgPSBib3VuZHM/LmVhcmxpZXN0ID8/IGF3YWl0IGdldEVhcmxpZXN0KCk7XG4gIGNvbnN0IGxhdGVzdCA9IGJvdW5kcz8ubGF0ZXN0ID8/IGF3YWl0IGdldExhdGVzdCgpO1xuICBjb25zdCBjbGFtcGVkID0gTWF0aC5tYXgodGFyZ2V0VHMsIGVhcmxpZXN0LnRzKTtcbiAgaWYgKGNsYW1wZWQgPD0gZWFybGllc3QudHMpIHJldHVybiBlYXJsaWVzdC5udW07XG4gIGlmIChjbGFtcGVkID4gbGF0ZXN0LnRzKSByZXR1cm4gbGF0ZXN0Lm51bTtcbiAgbGV0IGxvID0gZWFybGllc3QubnVtLCBoaSA9IGxhdGVzdC5udW07XG4gIHdoaWxlIChsbyA8IGhpKSB7XG4gICAgY29uc3QgbWlkID0gbG8gKyBNYXRoLmZsb29yKChoaSAtIGxvKSAvIDIpO1xuICAgIGNvbnN0IGIgPSBhd2FpdCBnZXRCbG9ja0J5TnVtYmVyKG1pZCk7XG4gICAgaWYgKGIudHMgPj0gY2xhbXBlZCkgaGkgPSBtaWQ7IGVsc2UgbG8gPSBtaWQgKyAxO1xuICB9XG4gIHJldHVybiBsbztcbn1cbmFzeW5jIGZ1bmN0aW9uIGZpbmRCbG9ja0F0T3JCZWZvcmUodGFyZ2V0VHM6IG51bWJlciwgYm91bmRzPzogQmxvY2tCb3VuZHMpOiBQcm9taXNlPG51bWJlcj4ge1xuICBjb25zdCBlYXJsaWVzdCA9IGJvdW5kcz8uZWFybGllc3QgPz8gYXdhaXQgZ2V0RWFybGllc3QoKTtcbiAgY29uc3QgbGF0ZXN0ID0gYm91bmRzPy5sYXRlc3QgPz8gYXdhaXQgZ2V0TGF0ZXN0KCk7XG4gIGNvbnN0IGNsYW1wZWQgPSBNYXRoLm1pbih0YXJnZXRUcywgbGF0ZXN0LnRzKTtcbiAgaWYgKGNsYW1wZWQgPCBlYXJsaWVzdC50cykgcmV0dXJuIGVhcmxpZXN0Lm51bTtcbiAgaWYgKGNsYW1wZWQgPj0gbGF0ZXN0LnRzKSByZXR1cm4gbGF0ZXN0Lm51bTtcbiAgbGV0IGxvID0gZWFybGllc3QubnVtLCBoaSA9IGxhdGVzdC5udW07XG4gIHdoaWxlIChsbyA8IGhpKSB7XG4gICAgY29uc3QgbWlkID0gbG8gKyBNYXRoLmZsb29yKChoaSAtIGxvICsgMSkgLyAyKTtcbiAgICBjb25zdCBiID0gYXdhaXQgZ2V0QmxvY2tCeU51bWJlcihtaWQpO1xuICAgIGlmIChiLnRzIDw9IGNsYW1wZWQpIGxvID0gbWlkOyBlbHNlIGhpID0gbWlkIC0gMTtcbiAgfVxuICByZXR1cm4gbG87XG59XG5cbmZ1bmN0aW9uIGJ1aWxkUmFuZ2VzKGZyb21CbG9jazogbnVtYmVyLCB0b0Jsb2NrOiBudW1iZXIpIHtcbiAgY29uc3QgcmFuZ2VzOiBBcnJheTx7IGZyb206IG51bWJlcjsgdG86IG51bWJlciB9PiA9IFtdO1xuICBsZXQgcyA9IGZyb21CbG9jaztcbiAgd2hpbGUgKHMgPD0gdG9CbG9jaykge1xuICAgIGNvbnN0IGUgPSBNYXRoLm1pbihzICsgTUFYX1NQQU4gLSAxLCB0b0Jsb2NrKTtcbiAgICByYW5nZXMucHVzaCh7IGZyb206IHMsIHRvOiBlIH0pO1xuICAgIHMgPSBlICsgMTtcbiAgfVxuICByZXR1cm4gcmFuZ2VzO1xufVxuXG5hc3luYyBmdW5jdGlvbiBnZXRMb2dzU2luZ2xlKGZyb21CbG9jazogbnVtYmVyLCB0b0Jsb2NrOiBudW1iZXIsIGNvbnRyYWN0OiBzdHJpbmcgPSBDT05UUkFDVCwgdG9waWMwOiBzdHJpbmcgPSBUT1BJQzApIHtcbiAgY29uc3QgaiA9IGF3YWl0IHJwYyh7IGpzb25ycGM6ICcyLjAnLCBpZDogMSwgbWV0aG9kOiAnZXRoX2dldExvZ3MnLCBwYXJhbXM6IFt7IGZyb21CbG9jazogdG9IZXgoZnJvbUJsb2NrKSwgdG9CbG9jazogdG9IZXgodG9CbG9jayksIGFkZHJlc3M6IGNvbnRyYWN0LCB0b3BpY3M6IFt0b3BpYzBdIH1dIH0pO1xuICBjb25zdCBhcnIgPSBqPy5yZXN1bHQgfHwgW107XG4gIC8vIERlZmVuc2l2ZTogc29tZSBSUEMgcHJvdmlkZXJzIGNhbiBvY2Nhc2lvbmFsbHkgcmV0dXJuIGR1cGxpY2F0ZSBsb2dzIGluIGxhcmdlIHJhbmdlc1xuICBjb25zdCB1bmlxID0gbmV3IE1hcDxzdHJpbmcsIGFueT4oKTtcbiAgZm9yIChjb25zdCBsb2cgb2YgYXJyKSB7XG4gICAgY29uc3Qga2V5ID0gYCR7bG9nLnRyYW5zYWN0aW9uSGFzaH0tJHtwYXJzZUludChsb2cubG9nSW5kZXgsIDE2KX1gO1xuICAgIHVuaXEuc2V0KGtleSwgbG9nKTtcbiAgfVxuICByZXR1cm4gQXJyYXkuZnJvbSh1bmlxLnZhbHVlcygpKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGdldExvZ3NDaHVua2VkKGZyb21CbG9jazogbnVtYmVyLCB0b0Jsb2NrOiBudW1iZXIsIGNvbnRyYWN0OiBzdHJpbmcgPSBDT05UUkFDVCwgdG9waWMwOiBzdHJpbmcgPSBUT1BJQzApIHtcbiAgY29uc3QgcmFuZ2VzID0gYnVpbGRSYW5nZXMoZnJvbUJsb2NrLCB0b0Jsb2NrKTtcbiAgbGV0IGFsbDogYW55W10gPSBbXTtcbiAgY29uc3QgQ09OQ1VSUkVOQ1kgPSBNYXRoLm1heCgxLCBMT0dfUkFOR0VfQ09OQ1VSUkVOQ1kpO1xuICBmb3IgKGxldCBpPTA7IGk8cmFuZ2VzLmxlbmd0aDsgaSs9Q09OQ1VSUkVOQ1kpIHtcbiAgICBjb25zdCBzbGljZSA9IHJhbmdlcy5zbGljZShpLCBpK0NPTkNVUlJFTkNZKTtcbiAgICBjb25zdCByZXFzID0gc2xpY2UubWFwKChyLCBpZHgpID0+IHJwYyh7IGpzb25ycGM6ICcyLjAnLCBpZDogMTAwMCtpK2lkeCwgbWV0aG9kOiAnZXRoX2dldExvZ3MnLCBwYXJhbXM6IFt7IGZyb21CbG9jazogdG9IZXgoci5mcm9tKSwgdG9CbG9jazogdG9IZXgoci50byksIGFkZHJlc3M6IGNvbnRyYWN0LCB0b3BpY3M6IFt0b3BpYzBdIH1dIH0pKTtcbiAgICBjb25zdCBwYXJ0cyA9IGF3YWl0IFByb21pc2UuYWxsKHJlcXMpO1xuICAgIGZvciAoY29uc3QgcCBvZiBwYXJ0cykgYWxsLnB1c2goLi4uKHA/LnJlc3VsdCB8fCBbXSkpO1xuICB9XG4gIGNvbnN0IHVuaXEgPSBuZXcgTWFwPHN0cmluZywgYW55PigpO1xuICBmb3IgKGNvbnN0IGxvZyBvZiBhbGwpIHtcbiAgICBjb25zdCBrZXkgPSBgJHtsb2cudHJhbnNhY3Rpb25IYXNofS0ke3BhcnNlSW50KGxvZy5sb2dJbmRleCwgMTYpfWA7XG4gICAgdW5pcS5zZXQoa2V5LCBsb2cpO1xuICB9XG4gIHJldHVybiBBcnJheS5mcm9tKHVuaXEudmFsdWVzKCkpO1xufVxuXG5mdW5jdGlvbiBkZWNvZGUobG9nOiBhbnkpOiBSb3cgfCBudWxsIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBwYXJzZWQgPSBpZmFjZS5wYXJzZUxvZyh7IHRvcGljczogbG9nLnRvcGljcywgZGF0YTogbG9nLmRhdGEgfSk7XG4gICAgY29uc3QgW2dhbWVOdW1iZXIsIGdhbWVJZCwgc3RhcnRlZEF0LCB3aW5uaW5nUGxheWVyLCB3aW5uaW5nQ2xhc3NlcywgbG9zaW5nUGxheWVyLCBsb3NpbmdDbGFzc2VzLCBnYW1lTGVuZ3RoLCBlbmRSZWFzb24sIGdhbWVUeXBlLCBtZXRhZGF0YV0gPSAocGFyc2VkIGFzIGFueSkuYXJncyBhcyBhbnlbXTtcbiAgICByZXR1cm4ge1xuICAgICAgYmxvY2tOdW1iZXI6IHBhcnNlSW50KGxvZy5ibG9ja051bWJlciwgMTYpLFxuICAgICAgdHhIYXNoOiBsb2cudHJhbnNhY3Rpb25IYXNoLFxuICAgICAgbG9nSW5kZXg6IHBhcnNlSW50KGxvZy5sb2dJbmRleCwgMTYpLFxuICAgICAgZ2FtZU51bWJlcjogTnVtYmVyKGdhbWVOdW1iZXI/LnRvU3RyaW5nPy4oKSA/PyBnYW1lTnVtYmVyKSxcbiAgICAgIGdhbWVJZDogU3RyaW5nKGdhbWVJZCksXG4gICAgICBzdGFydGVkQXQ6IFN0cmluZyhzdGFydGVkQXQpLFxuICAgICAgd2lubmluZ1BsYXllcjogbm9ybWFsaXplUGxheWVyKFN0cmluZyh3aW5uaW5nUGxheWVyKSksXG4gICAgICB3aW5uaW5nQ2xhc3NlczogU3RyaW5nKHdpbm5pbmdDbGFzc2VzKSxcbiAgICAgIGxvc2luZ1BsYXllcjogbm9ybWFsaXplUGxheWVyKFN0cmluZyhsb3NpbmdQbGF5ZXIpKSxcbiAgICAgIGxvc2luZ0NsYXNzZXM6IFN0cmluZyhsb3NpbmdDbGFzc2VzKSxcbiAgICAgIGdhbWVMZW5ndGg6IFN0cmluZyhnYW1lTGVuZ3RoKSxcbiAgICAgIGVuZFJlYXNvbjogU3RyaW5nKGVuZFJlYXNvbiksXG4gICAgICBnYW1lVHlwZTogZ2FtZVR5cGUgIT0gbnVsbCA/IFN0cmluZyhnYW1lVHlwZSkgOiB1bmRlZmluZWQsXG4gICAgICBtZXRhZGF0YTogbWV0YWRhdGEgIT0gbnVsbCA/IFN0cmluZyhtZXRhZGF0YSkgOiB1bmRlZmluZWQsXG4gICAgICBuZXR3b3JrOiAnbWVnYWV0aC10ZXN0bmV0LXYyJyxcbiAgICB9O1xuICB9IGNhdGNoIHsgcmV0dXJuIG51bGw7IH1cbn1cblxuZnVuY3Rpb24gZGVjb2RlTGVnYWN5KGxvZzogYW55KTogUm93IHwgbnVsbCB7XG4gIHRyeSB7XG4gICAgY29uc3QgcGFyc2VkID0gbGVnYWN5SWZhY2UucGFyc2VMb2coeyB0b3BpY3M6IGxvZy50b3BpY3MsIGRhdGE6IGxvZy5kYXRhIH0pO1xuICAgIGNvbnN0IFtnYW1lTnVtYmVyLCBnYW1lSWQsIHN0YXJ0ZWRBdCwgd2lubmluZ1BsYXllciwgd2lubmluZ0NsYXNzZXMsIGxvc2luZ1BsYXllciwgbG9zaW5nQ2xhc3NlcywgZ2FtZUxlbmd0aCwgZW5kUmVhc29uXSA9IChwYXJzZWQgYXMgYW55KS5hcmdzIGFzIGFueVtdO1xuICAgIHJldHVybiB7XG4gICAgICBibG9ja051bWJlcjogcGFyc2VJbnQobG9nLmJsb2NrTnVtYmVyLCAxNiksXG4gICAgICB0eEhhc2g6IGxvZy50cmFuc2FjdGlvbkhhc2gsXG4gICAgICBsb2dJbmRleDogcGFyc2VJbnQobG9nLmxvZ0luZGV4LCAxNiksXG4gICAgICBnYW1lTnVtYmVyOiBOdW1iZXIoZ2FtZU51bWJlcj8udG9TdHJpbmc/LigpID8/IGdhbWVOdW1iZXIpLFxuICAgICAgZ2FtZUlkOiBTdHJpbmcoZ2FtZUlkKSxcbiAgICAgIHN0YXJ0ZWRBdDogU3RyaW5nKHN0YXJ0ZWRBdCksXG4gICAgICB3aW5uaW5nUGxheWVyOiBub3JtYWxpemVQbGF5ZXIoU3RyaW5nKHdpbm5pbmdQbGF5ZXIpKSxcbiAgICAgIHdpbm5pbmdDbGFzc2VzOiBTdHJpbmcod2lubmluZ0NsYXNzZXMpLFxuICAgICAgbG9zaW5nUGxheWVyOiBub3JtYWxpemVQbGF5ZXIoU3RyaW5nKGxvc2luZ1BsYXllcikpLFxuICAgICAgbG9zaW5nQ2xhc3NlczogU3RyaW5nKGxvc2luZ0NsYXNzZXMpLFxuICAgICAgZ2FtZUxlbmd0aDogU3RyaW5nKGdhbWVMZW5ndGgpLFxuICAgICAgZW5kUmVhc29uOiBTdHJpbmcoZW5kUmVhc29uKSxcbiAgICAgIG5ldHdvcms6ICdsZWdhY3knLFxuICAgIH07XG4gIH0gY2F0Y2ggeyByZXR1cm4gbnVsbDsgfVxufVxuXG5mdW5jdGlvbiBkZWNvZGVMb2dzKGxvZ3M6IGFueVtdLCBpc0xlZ2FjeTogYm9vbGVhbiA9IGZhbHNlKTogUm93W10ge1xuICBjb25zdCBkZWNvZGVyID0gaXNMZWdhY3kgPyBkZWNvZGVMZWdhY3kgOiBkZWNvZGU7XG4gIHJldHVybiAobG9ncyBhcyBhbnlbXSkubWFwKGRlY29kZXIpLmZpbHRlcihCb29sZWFuKSBhcyBSb3dbXTtcbn1cblxuZnVuY3Rpb24gZGVkdXBlUm93cyhyb3dzOiBSb3dbXSk6IFJvd1tdIHtcbiAgY29uc3QgdW5pcSA9IG5ldyBNYXA8c3RyaW5nLCBSb3c+KCk7XG4gIGZvciAoY29uc3QgciBvZiByb3dzKSB7XG4gICAgY29uc3QgaWR4T3JCbG9jayA9ICh0eXBlb2YgKHIgYXMgYW55KS5sb2dJbmRleCA9PT0gJ251bWJlcicgJiYgIWlzTmFOKChyIGFzIGFueSkubG9nSW5kZXgpKSA/IChyIGFzIGFueSkubG9nSW5kZXggOiByLmJsb2NrTnVtYmVyO1xuICAgIHVuaXEuc2V0KGAke3IudHhIYXNofToke2lkeE9yQmxvY2t9YCwgcik7XG4gIH1cbiAgcmV0dXJuIEFycmF5LmZyb20odW5pcS52YWx1ZXMoKSk7XG59XG5mdW5jdGlvbiBtZXJnZVJvd3MoYTogUm93W10sIGI6IFJvd1tdKTogUm93W10ge1xuICBjb25zdCBtYXAgPSBuZXcgTWFwPHN0cmluZywgUm93PigpO1xuICBmb3IgKGNvbnN0IHIgb2YgYSkgbWFwLnNldChzdGFibGVSb3dLZXkociksIHIpO1xuICBmb3IgKGNvbnN0IHIgb2YgYikgbWFwLnNldChzdGFibGVSb3dLZXkociksIHIpO1xuICByZXR1cm4gQXJyYXkuZnJvbShtYXAudmFsdWVzKCkpO1xufVxuZnVuY3Rpb24gaGFzTWVnYVJvd3MoZW50cnk6IERheUVudHJ5IHwgbnVsbCB8IHVuZGVmaW5lZCkge1xuICByZXR1cm4gQm9vbGVhbihlbnRyeT8ucm93cz8uc29tZShyID0+IHIubmV0d29yayA9PT0gJ21lZ2FldGgtdGVzdG5ldC12MicpKTtcbn1cbmZ1bmN0aW9uIG1lcmdlRGF5RW50cmllcyhhOiBEYXlFbnRyeSB8IG51bGwsIGI6IERheUVudHJ5IHwgbnVsbCk6IERheUVudHJ5IHwgbnVsbCB7XG4gIGlmICghYSkgcmV0dXJuIGI7XG4gIGlmICghYikgcmV0dXJuIGE7XG4gIGNvbnN0IHJvd3MgPSBkZWR1cGVSb3dzKFsuLi5hLnJvd3MsIC4uLmIucm93c10pLnNvcnQoc29ydEJ5VGltZXN0YW1wKTtcbiAgcmV0dXJuIHtcbiAgICBmcm9tQmxvY2s6IE1hdGgubWluKGEuZnJvbUJsb2NrLCBiLmZyb21CbG9jayksXG4gICAgdG9CbG9jazogTWF0aC5tYXgoYS50b0Jsb2NrLCBiLnRvQmxvY2spLFxuICAgIHJvd3MsXG4gICAgbGFzdFVwZGF0ZTogRGF0ZS5ub3coKSxcbiAgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGVuc3VyZU1lZ2FSb3dzKGVudHJ5OiBEYXlFbnRyeSB8IG51bGwsIGRheVN0YXJ0VHM6IG51bWJlciwgZGF5RW5kVHM6IG51bWJlciwgYm91bmRzOiBCbG9ja0JvdW5kcykge1xuICBpZiAoaGFzTWVnYVJvd3MoZW50cnkpKSByZXR1cm4gZW50cnkhO1xuICBjb25zdCBidWlsdCA9IGF3YWl0IGJ1aWxkRGF5KGRheVN0YXJ0VHMsIGRheUVuZFRzLCBib3VuZHMpO1xuICBjb25zdCBtZXJnZWQgPSBtZXJnZURheUVudHJpZXMoZW50cnksIGJ1aWx0LmVudHJ5KTtcbiAgcmV0dXJuIG1lcmdlZCB8fCBidWlsdC5lbnRyeTtcbn1cblxuZnVuY3Rpb24gcGFyc2VTdGFydGVkQXRUcyhzdHI6IHN0cmluZyk6IG51bWJlciB8IG51bGwge1xuICBpZiAoIXN0cikgcmV0dXJuIG51bGw7XG4gIC8vIENvbW1vbiBvbi1jaGFpbiBzdHJpbmc6IFwiWVlZWS1NTS1ERCBISDptbTpzcyBVVENcIlxuICBjb25zdCBtID0gL14oWzAtOV17NH0pLShbMC05XXsyfSktKFswLTldezJ9KVsgVF0oWzAtOV17Mn0pOihbMC05XXsyfSk6KFswLTldezJ9KSg/OlxccyooPzpVVEN8WikpPyQvaS5leGVjKHN0ci50cmltKCkpO1xuICBpZiAobSkge1xuICAgIGNvbnN0IHllYXIgPSBOdW1iZXIobVsxXSk7XG4gICAgY29uc3QgbW9udGggPSBOdW1iZXIobVsyXSkgLSAxOyAvLyBKUyBtb250aHMgYXJlIDAtYmFzZWRcbiAgICBjb25zdCBkYXkgPSBOdW1iZXIobVszXSk7XG4gICAgY29uc3QgaG91ciA9IE51bWJlcihtWzRdKTtcbiAgICBjb25zdCBtaW51dGUgPSBOdW1iZXIobVs1XSk7XG4gICAgY29uc3Qgc2Vjb25kID0gTnVtYmVyKG1bNl0pO1xuICAgIGNvbnN0IG1zID0gRGF0ZS5VVEMoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQpO1xuICAgIHJldHVybiBNYXRoLmZsb29yKG1zIC8gMTAwMCk7XG4gIH1cbiAgLy8gRmFsbGJhY2s6IHRyeSB0byBjb2VyY2UgdG8gSVNPXG4gIGNvbnN0IGlzbyA9IHN0ci5yZXBsYWNlKCcgJywgJ1QnKS5yZXBsYWNlKC9cXHMqVVRDJC9pLCAnWicpO1xuICBjb25zdCBtcyA9IERhdGUucGFyc2UoaXNvKTtcbiAgaWYgKGlzTmFOKG1zKSkgcmV0dXJuIG51bGw7XG4gIHJldHVybiBNYXRoLmZsb29yKG1zIC8gMTAwMCk7XG59XG5mdW5jdGlvbiBzb3J0QnlUaW1lc3RhbXAoYTogUm93LCBiOiBSb3cpOiBudW1iZXIge1xuICBjb25zdCB0c0EgPSBwYXJzZVN0YXJ0ZWRBdFRzKGEuc3RhcnRlZEF0KTtcbiAgY29uc3QgdHNCID0gcGFyc2VTdGFydGVkQXRUcyhiLnN0YXJ0ZWRBdCk7XG4gIGlmICh0c0EgIT09IG51bGwgJiYgdHNCICE9PSBudWxsKSByZXR1cm4gdHNCIC0gdHNBOyAvLyBuZXdlc3QgZmlyc3RcbiAgaWYgKHRzQSAhPT0gbnVsbCkgcmV0dXJuIC0xOyAvLyBhIGhhcyB0aW1lc3RhbXAsIGIgZG9lc24ndCAtIGEgY29tZXMgZmlyc3RcbiAgaWYgKHRzQiAhPT0gbnVsbCkgcmV0dXJuIDE7IC8vIGIgaGFzIHRpbWVzdGFtcCwgYSBkb2Vzbid0IC0gYiBjb21lcyBmaXJzdFxuICByZXR1cm4gYi5ibG9ja051bWJlciAtIGEuYmxvY2tOdW1iZXI7IC8vIGZhbGxiYWNrIHRvIGJsb2NrTnVtYmVyIChuZXdlc3QgZmlyc3QpXG59XG5mdW5jdGlvbiBmaWx0ZXJSb3dzQnlUcyhyb3dzOiBSb3dbXSwgc3RhcnRUczogbnVtYmVyLCBlbmRUczogbnVtYmVyKTogUm93W10ge1xuICByZXR1cm4gcm93cy5maWx0ZXIoKHIpID0+IHtcbiAgICBjb25zdCB0cyA9IHBhcnNlU3RhcnRlZEF0VHMoci5zdGFydGVkQXQpO1xuICAgIGlmICh0cyA9PSBudWxsKSByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gdHMgPj0gc3RhcnRUcyAmJiB0cyA8PSBlbmRUcztcbiAgfSk7XG59XG5mdW5jdGlvbiBzdGFibGVSb3dLZXkocjogUm93KTogc3RyaW5nIHtcbiAgY29uc3QgYW55UjogYW55ID0gciBhcyBhbnk7XG4gIGlmICh0eXBlb2YgYW55Ui5sb2dJbmRleCA9PT0gJ251bWJlcicgJiYgIWlzTmFOKGFueVIubG9nSW5kZXgpKSByZXR1cm4gYCR7ci50eEhhc2h9OiR7YW55Ui5sb2dJbmRleH1gO1xuICBpZiAoci5nYW1lSWQpIHJldHVybiBgZ2lkOiR7ci5nYW1lSWR9YDtcbiAgcmV0dXJuIGAke3IudHhIYXNofToke3IuYmxvY2tOdW1iZXJ9YDtcbn1cblxuYXN5bmMgZnVuY3Rpb24gYnVpbGREYXkoZGF5U3RhcnRUczogbnVtYmVyLCBkYXlFbmRUczogbnVtYmVyLCBib3VuZHM6IEJsb2NrQm91bmRzKSB7XG4gIGNvbnN0IGtleSA9IE1hdGguZmxvb3IoZGF5U3RhcnRUcyAvIDg2NDAwKTtcbiAgY29uc3Qgc2FmZVN0YXJ0ID0gTWF0aC5tYXgoZGF5U3RhcnRUcywgYm91bmRzLmVhcmxpZXN0LnRzKTtcbiAgY29uc3QgZW5kVHMgPSBNYXRoLm1pbihNYXRoLm1heChkYXlFbmRUcywgMCksIGJvdW5kcy5sYXRlc3QudHMpO1xuICBjb25zdCBmcm9tQmxvY2sgPSBhd2FpdCBmaW5kQmxvY2tBdE9yQWZ0ZXIoc2FmZVN0YXJ0LCBib3VuZHMpO1xuICBjb25zdCB0b0Jsb2NrID0gYXdhaXQgZmluZEJsb2NrQXRPckJlZm9yZShlbmRUcywgYm91bmRzKTtcbiAgaWYgKHRvQmxvY2sgPCBmcm9tQmxvY2spIHJldHVybiB7IGtleSwgZW50cnk6IHsgZnJvbUJsb2NrLCB0b0Jsb2NrLCByb3dzOiBbXSwgbGFzdFVwZGF0ZTogRGF0ZS5ub3coKSB9IH07XG4gIFxuICAvLyBEZXRlcm1pbmUgd2hpY2ggY29udHJhY3QgdG8gdXNlIGJhc2VkIG9uIHRoZSBkYXkgc3RhcnQgdGltZXN0YW1wXG4gIC8vIEZvciBOb3YgMTUgYW5kIGxhdGVyLCB1c2UgbmV3IGNvbnRyYWN0OyBiZWZvcmUgTm92IDE1LCB1c2UgbGVnYWN5XG4gIGNvbnN0IGlzTGVnYWN5RGF5ID0gZGF5U3RhcnRUcyA8IE5FV19DT05UUkFDVF9TVEFSVF9UUztcbiAgY29uc3QgY29udHJhY3QgPSBpc0xlZ2FjeURheSA/IExFR0FDWV9DT05UUkFDVCA6IENPTlRSQUNUO1xuICBjb25zdCB0b3BpYzAgPSBpc0xlZ2FjeURheSA/IExFR0FDWV9UT1BJQzAgOiBUT1BJQzA7XG4gIGNvbnN0IGlzTGVnYWN5ID0gaXNMZWdhY3lEYXk7XG4gIFxuICAvLyBTYWZldHk6IEZvciBkYXlzIGFmdGVyIE5vdiAxNSwgZW5zdXJlIHdlJ3JlIHVzaW5nIHRoZSBuZXcgY29udHJhY3RcbiAgaWYgKGRheVN0YXJ0VHMgPj0gTkVXX0NPTlRSQUNUX1NUQVJUX1RTICYmIGNvbnRyYWN0ICE9PSBDT05UUkFDVCkge1xuICAgIC8vIFRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbiwgYnV0IGlmIGl0IGRvZXMsIHVzZSBuZXcgY29udHJhY3RcbiAgICBjb25zdCBsb2dzID0gYXdhaXQgZ2V0TG9nc0NodW5rZWQoZnJvbUJsb2NrLCB0b0Jsb2NrLCBDT05UUkFDVCwgVE9QSUMwKTtcbiAgICBjb25zdCByb3dzID0gZGVkdXBlUm93cyhkZWNvZGVMb2dzKGxvZ3MsIGZhbHNlKSk7XG4gICAgcmV0dXJuIHsga2V5LCBlbnRyeTogeyBmcm9tQmxvY2ssIHRvQmxvY2ssIHJvd3MsIGxhc3RVcGRhdGU6IERhdGUubm93KCkgfSB9O1xuICB9XG4gIFxuICB0cnkge1xuICAgIGNvbnN0IGxvZ3MgPSBhd2FpdCBnZXRMb2dzU2luZ2xlKGZyb21CbG9jaywgdG9CbG9jaywgY29udHJhY3QsIHRvcGljMCk7XG4gICAgY29uc3Qgcm93cyA9IGRlZHVwZVJvd3MoZGVjb2RlTG9ncyhsb2dzLCBpc0xlZ2FjeSkpO1xuICAgIHJldHVybiB7IGtleSwgZW50cnk6IHsgZnJvbUJsb2NrLCB0b0Jsb2NrLCByb3dzLCBsYXN0VXBkYXRlOiBEYXRlLm5vdygpIH0gfTtcbiAgfSBjYXRjaCB7XG4gICAgY29uc3QgbG9ncyA9IGF3YWl0IGdldExvZ3NDaHVua2VkKGZyb21CbG9jaywgdG9CbG9jaywgY29udHJhY3QsIHRvcGljMCk7XG4gICAgY29uc3Qgcm93cyA9IGRlZHVwZVJvd3MoZGVjb2RlTG9ncyhsb2dzLCBpc0xlZ2FjeSkpO1xuICAgIHJldHVybiB7IGtleSwgZW50cnk6IHsgZnJvbUJsb2NrLCB0b0Jsb2NrLCByb3dzLCBsYXN0VXBkYXRlOiBEYXRlLm5vdygpIH0gfTtcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBleHRlbmRUb2RheShleGlzdGluZzogRGF5RW50cnksIGRheVN0YXJ0VHM6IG51bWJlciwgZGF5RW5kVHM6IG51bWJlciwgYm91bmRzOiBCbG9ja0JvdW5kcyk6IFByb21pc2U8RGF5RW50cnk+IHtcbiAgY29uc3QgZnJvbUJsb2NrID0gZXhpc3RpbmcudG9CbG9jayArIDE7XG4gIGNvbnN0IHRvQmxvY2sgPSBhd2FpdCBmaW5kQmxvY2tBdE9yQmVmb3JlKE1hdGgubWluKE1hdGgubWF4KGRheUVuZFRzLCAwKSwgYm91bmRzLmxhdGVzdC50cyksIGJvdW5kcyk7XG4gIGlmICh0b0Jsb2NrIDwgZnJvbUJsb2NrKSByZXR1cm4gZXhpc3Rpbmc7XG4gIGxldCBuZXdMb2dzOiBhbnlbXSA9IFtdO1xuICB0cnkge1xuICAgIG5ld0xvZ3MgPSBhd2FpdCBnZXRMb2dzU2luZ2xlKGZyb21CbG9jaywgdG9CbG9jayk7XG4gIH0gY2F0Y2gge1xuICAgIG5ld0xvZ3MgPSBhd2FpdCBnZXRMb2dzQ2h1bmtlZChmcm9tQmxvY2ssIHRvQmxvY2spO1xuICB9XG4gIGNvbnN0IG5ld1Jvd3MgPSAobmV3TG9ncyBhcyBhbnlbXSkubWFwKGRlY29kZSkuZmlsdGVyKEJvb2xlYW4pIGFzIFJvd1tdO1xuICBjb25zdCBtZXJnZWQgPSBbLi4uZXhpc3Rpbmcucm93cywgLi4ubmV3Um93c107XG4gIGNvbnN0IHVuaXEgPSBuZXcgTWFwPHN0cmluZywgUm93PigpO1xuICBmb3IgKGNvbnN0IHIgb2YgbWVyZ2VkKSB7XG4gICAgY29uc3QgaWR4T3JCbG9jayA9ICh0eXBlb2YgKHIgYXMgYW55KS5sb2dJbmRleCA9PT0gJ251bWJlcicgJiYgIWlzTmFOKChyIGFzIGFueSkubG9nSW5kZXgpKSA/IChyIGFzIGFueSkubG9nSW5kZXggOiByLmJsb2NrTnVtYmVyO1xuICAgIHVuaXEuc2V0KGAke3IudHhIYXNofToke2lkeE9yQmxvY2t9YCwgcik7XG4gIH1cbiAgcmV0dXJuIHsgZnJvbUJsb2NrOiBleGlzdGluZy5mcm9tQmxvY2ssIHRvQmxvY2ssIHJvd3M6IEFycmF5LmZyb20odW5pcS52YWx1ZXMoKSksIGxhc3RVcGRhdGU6IERhdGUubm93KCkgfTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZmV0Y2hSYW5nZVJvd3NEaXJlY3Qoc3RhcnRUczogbnVtYmVyLCBlbmRUczogbnVtYmVyLCBib3VuZHM6IEJsb2NrQm91bmRzKTogUHJvbWlzZTxSb3dbXT4ge1xuICBjb25zdCBjbGFtcGVkU3RhcnQgPSBNYXRoLm1heChzdGFydFRzLCBib3VuZHMuZWFybGllc3QudHMpO1xuICBjb25zdCBjbGFtcGVkRW5kID0gTWF0aC5taW4oTWF0aC5tYXgoZW5kVHMsIGNsYW1wZWRTdGFydCksIGJvdW5kcy5sYXRlc3QudHMpO1xuICBpZiAoY2xhbXBlZEVuZCA8IGNsYW1wZWRTdGFydCkgcmV0dXJuIFtdO1xuICBcbiAgLy8gT3B0aW1pemU6IG9ubHkgcXVlcnkgY29udHJhY3RzIHRoYXQgaGF2ZSBkYXRhIGZvciB0aGlzIGRhdGUgcmFuZ2VcbiAgY29uc3QgbmVlZHNMZWdhY3kgPSBjbGFtcGVkU3RhcnQgPCBORVdfQ09OVFJBQ1RfU1RBUlRfVFM7XG4gIGNvbnN0IG5lZWRzTmV3ID0gY2xhbXBlZEVuZCA+PSBORVdfQ09OVFJBQ1RfU1RBUlRfVFM7XG4gIFxuICBjb25zdCBxdWVyaWVzOiBQcm9taXNlPFJvd1tdPltdID0gW107XG4gIFxuICBpZiAobmVlZHNMZWdhY3kpIHtcbiAgICAvLyBRdWVyeSBsZWdhY3kgY29udHJhY3QgZm9yIGRhdGVzIGJlZm9yZSBuZXcgY29udHJhY3Qgc3RhcnRlZFxuICAgIGNvbnN0IGxlZ2FjeUVuZFRzID0gTWF0aC5taW4oY2xhbXBlZEVuZCwgTkVXX0NPTlRSQUNUX1NUQVJUX1RTIC0gMSk7XG4gICAgY29uc3QgbGVnYWN5RnJvbUJsb2NrID0gYXdhaXQgZmluZEJsb2NrQXRPckFmdGVyKGNsYW1wZWRTdGFydCwgYm91bmRzKTtcbiAgICBjb25zdCBsZWdhY3lUb0Jsb2NrID0gYXdhaXQgZmluZEJsb2NrQXRPckJlZm9yZShsZWdhY3lFbmRUcywgYm91bmRzKTtcbiAgICBpZiAobGVnYWN5VG9CbG9jayA+PSBsZWdhY3lGcm9tQmxvY2spIHtcbiAgICAgIHF1ZXJpZXMucHVzaCgoYXN5bmMgKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGxvZ3MgPSBhd2FpdCBnZXRMb2dzU2luZ2xlKGxlZ2FjeUZyb21CbG9jaywgbGVnYWN5VG9CbG9jaywgTEVHQUNZX0NPTlRSQUNULCBMRUdBQ1lfVE9QSUMwKTtcbiAgICAgICAgICByZXR1cm4gZGVkdXBlUm93cyhkZWNvZGVMb2dzKGxvZ3MsIHRydWUpKTtcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgY29uc3QgbG9ncyA9IGF3YWl0IGdldExvZ3NDaHVua2VkKGxlZ2FjeUZyb21CbG9jaywgbGVnYWN5VG9CbG9jaywgTEVHQUNZX0NPTlRSQUNULCBMRUdBQ1lfVE9QSUMwKTtcbiAgICAgICAgICByZXR1cm4gZGVkdXBlUm93cyhkZWNvZGVMb2dzKGxvZ3MsIHRydWUpKTtcbiAgICAgICAgfVxuICAgICAgfSkoKSk7XG4gICAgfVxuICB9XG4gIFxuICBpZiAobmVlZHNOZXcpIHtcbiAgICAvLyBRdWVyeSBuZXcgY29udHJhY3QgZm9yIGRhdGVzIGFmdGVyIGl0IHN0YXJ0ZWRcbiAgICBjb25zdCBuZXdTdGFydFRzID0gTWF0aC5tYXgoY2xhbXBlZFN0YXJ0LCBORVdfQ09OVFJBQ1RfU1RBUlRfVFMpO1xuICAgIGNvbnN0IG5ld0Zyb21CbG9jayA9IGF3YWl0IGZpbmRCbG9ja0F0T3JBZnRlcihuZXdTdGFydFRzLCBib3VuZHMpO1xuICAgIGNvbnN0IG5ld1RvQmxvY2sgPSBhd2FpdCBmaW5kQmxvY2tBdE9yQmVmb3JlKGNsYW1wZWRFbmQsIGJvdW5kcyk7XG4gICAgaWYgKG5ld1RvQmxvY2sgPj0gbmV3RnJvbUJsb2NrKSB7XG4gICAgICBxdWVyaWVzLnB1c2goKGFzeW5jICgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBFbnN1cmUgd2UncmUgdXNpbmcgdGhlIGNvcnJlY3QgY29udHJhY3QgYW5kIHRvcGljXG4gICAgICAgICAgaWYgKENPTlRSQUNUICE9PSAnMHg4NmI2ZjM4NTZmMDg2Y2QyOTQ2Mjk4NWY3YmJmZjBkNTVkMmI1ZDUzJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBXcm9uZyBjb250cmFjdCBhZGRyZXNzOiAke0NPTlRSQUNUfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBsb2dzID0gYXdhaXQgZ2V0TG9nc1NpbmdsZShuZXdGcm9tQmxvY2ssIG5ld1RvQmxvY2ssIENPTlRSQUNULCBUT1BJQzApO1xuICAgICAgICAgIGNvbnN0IGRlY29kZWQgPSBkZWNvZGVMb2dzKGxvZ3MsIGZhbHNlKTtcbiAgICAgICAgICBjb25zdCBkZWR1cGVkID0gZGVkdXBlUm93cyhkZWNvZGVkKTtcbiAgICAgICAgICBpZiAoZGVkdXBlZC5sZW5ndGggPT09IDAgJiYgbG9ncy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdEZWNvZGVkIGxvZ3MgYnV0IGdvdCAwIHJvd3MnLCB7IGxvZ3NMZW5ndGg6IGxvZ3MubGVuZ3RoLCBmcm9tQmxvY2s6IG5ld0Zyb21CbG9jaywgdG9CbG9jazogbmV3VG9CbG9jayB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGRlZHVwZWQ7XG4gICAgICAgIH0gY2F0Y2ggKGVycjogYW55KSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignZ2V0TG9nc1NpbmdsZSBmYWlsZWQsIHRyeWluZyBjaHVua2VkJywgeyBcbiAgICAgICAgICAgIGVycm9yOiBlcnI/Lm1lc3NhZ2UgfHwgU3RyaW5nKGVyciksXG4gICAgICAgICAgICBmcm9tQmxvY2s6IG5ld0Zyb21CbG9jayxcbiAgICAgICAgICAgIHRvQmxvY2s6IG5ld1RvQmxvY2ssXG4gICAgICAgICAgICBjb250cmFjdDogQ09OVFJBQ1QsXG4gICAgICAgICAgICB0b3BpYzA6IFRPUElDMFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBsb2dzID0gYXdhaXQgZ2V0TG9nc0NodW5rZWQobmV3RnJvbUJsb2NrLCBuZXdUb0Jsb2NrLCBDT05UUkFDVCwgVE9QSUMwKTtcbiAgICAgICAgICAgIGNvbnN0IGRlY29kZWQgPSBkZWNvZGVMb2dzKGxvZ3MsIGZhbHNlKTtcbiAgICAgICAgICAgIGNvbnN0IGRlZHVwZWQgPSBkZWR1cGVSb3dzKGRlY29kZWQpO1xuICAgICAgICAgICAgcmV0dXJuIGRlZHVwZWQ7XG4gICAgICAgICAgfSBjYXRjaCAoY2h1bmtFcnI6IGFueSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignZ2V0TG9nc0NodW5rZWQgYWxzbyBmYWlsZWQnLCB7XG4gICAgICAgICAgICAgIGVycm9yOiBjaHVua0Vycj8ubWVzc2FnZSB8fCBTdHJpbmcoY2h1bmtFcnIpLFxuICAgICAgICAgICAgICBmcm9tQmxvY2s6IG5ld0Zyb21CbG9jayxcbiAgICAgICAgICAgICAgdG9CbG9jazogbmV3VG9CbG9ja1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gW107IC8vIFJldHVybiBlbXB0eSBpbnN0ZWFkIG9mIHRocm93aW5nXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KSgpKTtcbiAgICB9XG4gIH1cbiAgXG4gIGlmIChxdWVyaWVzLmxlbmd0aCA9PT0gMCkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ2ZldGNoUmFuZ2VSb3dzRGlyZWN0OiBObyBxdWVyaWVzIHRvIGV4ZWN1dGUnLCB7IHN0YXJ0VHMsIGVuZFRzLCBuZWVkc0xlZ2FjeSwgbmVlZHNOZXcgfSk7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIFxuICAvLyBFeGVjdXRlIHF1ZXJpZXMgaW4gcGFyYWxsZWwgd2l0aCBlcnJvciBoYW5kbGluZ1xuICBsZXQgcmVzdWx0czogUm93W11bXTtcbiAgdHJ5IHtcbiAgICByZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwocXVlcmllcyk7XG4gIH0gY2F0Y2ggKGVycjogYW55KSB7XG4gICAgY29uc29sZS5lcnJvcignZmV0Y2hSYW5nZVJvd3NEaXJlY3Q6IFByb21pc2UuYWxsIGZhaWxlZCcsIHtcbiAgICAgIGVycm9yOiBlcnI/Lm1lc3NhZ2UgfHwgU3RyaW5nKGVyciksXG4gICAgICBzdGFydFRzLFxuICAgICAgZW5kVHMsXG4gICAgICBxdWVyaWVzQ291bnQ6IHF1ZXJpZXMubGVuZ3RoXG4gICAgfSk7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIFxuICAvLyBNZXJnZSBhbGwgcmVzdWx0c1xuICBsZXQgYWxsUm93czogUm93W10gPSBbXTtcbiAgZm9yIChjb25zdCByb3dzIG9mIHJlc3VsdHMpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShyb3dzKSkge1xuICAgICAgYWxsUm93cyA9IG1lcmdlUm93cyhhbGxSb3dzLCByb3dzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5lcnJvcignZmV0Y2hSYW5nZVJvd3NEaXJlY3Q6IEludmFsaWQgcm93cyByZXN1bHQnLCB7IHJvd3MgfSk7XG4gICAgfVxuICB9XG4gIGFsbFJvd3Muc29ydChzb3J0QnlUaW1lc3RhbXApO1xuICBcbiAgaWYgKGFsbFJvd3MubGVuZ3RoID09PSAwICYmIGVuZFRzID49IE5FV19DT05UUkFDVF9TVEFSVF9UUykge1xuICAgIGNvbnNvbGUuZXJyb3IoJ2ZldGNoUmFuZ2VSb3dzRGlyZWN0OiBHb3QgMCByb3dzIGZvciBuZXcgY29udHJhY3QgcmFuZ2UnLCB7XG4gICAgICBzdGFydFRzLFxuICAgICAgZW5kVHMsXG4gICAgICBuZWVkc05ldyxcbiAgICAgIHF1ZXJpZXNDb3VudDogcXVlcmllcy5sZW5ndGgsXG4gICAgICByZXN1bHRzTGVuZ3RoczogcmVzdWx0cy5tYXAociA9PiBBcnJheS5pc0FycmF5KHIpID8gci5sZW5ndGggOiAnaW52YWxpZCcpXG4gICAgfSk7XG4gIH1cbiAgXG4gIHJldHVybiBhbGxSb3dzO1xufVxuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBoYW5kbGVyKHJlcTogTmV4dEFwaVJlcXVlc3QsIHJlczogTmV4dEFwaVJlc3BvbnNlKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgeyBzdGFydFRzLCBlbmRUcywgcmVidWlsZERheSwgd2FudEFnZyB9ID0gKHJlcS5ib2R5IHx8IHt9KSBhcyB7IHN0YXJ0VHM/OiBudW1iZXI7IGVuZFRzPzogbnVtYmVyOyByZWJ1aWxkRGF5PzogbnVtYmVyOyB3YW50QWdnPzogYm9vbGVhbiB9O1xuICAgIC8vIEFkbWluOiByZWJ1aWxkIGEgc3BlY2lmaWMgZGF5IChVVEMgZGF5IGluZGV4KVxuICAgIGlmICh0eXBlb2YgcmVidWlsZERheSA9PT0gJ251bWJlcicgJiYgcmVidWlsZERheSA+PSAwKSB7XG4gICAgICBjb25zdCBlYXJsaWVzdCA9IGF3YWl0IGdldEVhcmxpZXN0KCk7XG4gICAgICBjb25zdCBsYXRlc3QgPSBhd2FpdCBnZXRMYXRlc3QoKTtcbiAgICAgIGNvbnN0IGJvdW5kczogQmxvY2tCb3VuZHMgPSB7IGVhcmxpZXN0LCBsYXRlc3QgfTtcbiAgICAgIGNvbnN0IHN0YXJ0ID0gcmVidWlsZERheSAqIDg2NDAwO1xuICAgICAgY29uc3QgZW5kID0gc3RhcnQgKyA4NjM5OTtcbiAgICAgIGNvbnN0IGJ1aWx0ID0gYXdhaXQgYnVpbGREYXkoc3RhcnQsIGVuZCwgYm91bmRzKTtcbiAgICAgIHJlbWVtYmVyKGJ1aWx0LmtleSwgYnVpbHQuZW50cnkpO1xuICAgICAgYXdhaXQga3ZTZXREYXkoYnVpbHQua2V5LCBidWlsdC5lbnRyeSk7XG4gICAgICByZXR1cm4gc2VuZEpzb24ocmVzLCAyMDAsIHsgb2s6IHRydWUsIHJlYnVpbHQ6IGJ1aWx0LmtleSwgZnJvbUJsb2NrOiBidWlsdC5lbnRyeS5mcm9tQmxvY2ssIHRvQmxvY2s6IGJ1aWx0LmVudHJ5LnRvQmxvY2ssIHJvd3M6IGJ1aWx0LmVudHJ5LnJvd3MubGVuZ3RoIH0pO1xuICAgIH1cbiAgICBjb25zdCBlYXJsaWVzdCA9IGF3YWl0IGdldEVhcmxpZXN0KCk7XG4gICAgY29uc3QgbGF0ZXN0ID0gYXdhaXQgZ2V0TGF0ZXN0KCk7XG4gICAgY29uc3QgYm91bmRzOiBCbG9ja0JvdW5kcyA9IHsgZWFybGllc3QsIGxhdGVzdCB9O1xuXG4gICAgY29uc3Qgc1RzID0gdHlwZW9mIHN0YXJ0VHMgPT09ICdudW1iZXInICYmIHN0YXJ0VHMgPiAwID8gc3RhcnRUcyA6IGVhcmxpZXN0LnRzO1xuICAgIGNvbnN0IGVUcyA9IHR5cGVvZiBlbmRUcyA9PT0gJ251bWJlcicgJiYgZW5kVHMgPiAwID8gZW5kVHMgOiBsYXRlc3QudHM7XG4gICAgaWYgKGVUcyA8IHNUcykgcmV0dXJuIHNlbmRKc29uKHJlcywgMjAwLCB7IG9rOiB0cnVlLCByb3dzOiBbXSB9KTtcblxuICAgIGxldCByZXN1bHRSb3dzOiBSb3dbXSA9IFtdO1xuXG4gICAgaWYgKCFLVl9FTlZfUFJFU0VOVCkge1xuICAgICAgcmVzdWx0Um93cyA9IGF3YWl0IGZldGNoUmFuZ2VSb3dzRGlyZWN0KHNUcywgZVRzLCBib3VuZHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTSU1QTElGSUVEIEFQUFJPQUNIOiBTcGxpdCBxdWVyeSBpbnRvIHR3byBwYXJ0c1xuICAgICAgLy8gMS4gRGF5cyBiZWZvcmUgTm92IDE1OiB1c2UgY2FjaGUgKGZhc3QsIHByb3ZlbiB0byB3b3JrKVxuICAgICAgLy8gMi4gRGF5cyBhZnRlciBOb3YgMTQ6IEFMV0FZUyBmZXRjaCBkaXJlY3RseSB1c2luZyBmZXRjaFJhbmdlUm93c0RpcmVjdCAoZ3VhcmFudGVlZCB0byB3b3JrKVxuICAgICAgXG4gICAgICBjb25zdCBiZWZvcmVOZXdDb250cmFjdEVuZCA9IE1hdGgubWluKGVUcywgTkVXX0NPTlRSQUNUX1NUQVJUX1RTIC0gMSk7XG4gICAgICBjb25zdCBhZnRlck5ld0NvbnRyYWN0U3RhcnQgPSBNYXRoLm1heChzVHMsIE5FV19DT05UUkFDVF9TVEFSVF9UUyk7XG4gICAgICBcbiAgICAgIC8vIEZldGNoIGRheXMgYmVmb3JlIE5vdiAxNSB1c2luZyBjYWNoZVxuICAgICAgLy8gSU1QT1JUQU5UOiBTa2lwIGRheXMgYWZ0ZXIgTm92IDE0IC0gdGhleSdyZSBmZXRjaGVkIGRpcmVjdGx5IGJlbG93XG4gICAgICBpZiAoc1RzIDwgTkVXX0NPTlRSQUNUX1NUQVJUX1RTICYmIGJlZm9yZU5ld0NvbnRyYWN0RW5kID49IHNUcykge1xuICAgICAgICBjb25zdCBzdGFydERheSA9IE1hdGguZmxvb3Ioc1RzIC8gODY0MDApO1xuICAgICAgICBjb25zdCBlbmREYXkgPSBNYXRoLmZsb29yKGJlZm9yZU5ld0NvbnRyYWN0RW5kIC8gODY0MDApO1xuICAgICAgICBjb25zdCB0b2RheURheSA9IE1hdGguZmxvb3IobGF0ZXN0LnRzIC8gODY0MDApO1xuICAgICAgICBjb25zdCBuZXdDb250cmFjdFN0YXJ0RGF5ID0gTWF0aC5mbG9vcihORVdfQ09OVFJBQ1RfU1RBUlRfVFMgLyA4NjQwMCk7XG5cbiAgICAgIGNvbnN0IGRheVJhbmdlczogQXJyYXk8eyBrZXk6bnVtYmVyLCBzdGFydDpudW1iZXIsIGVuZDpudW1iZXIgfT4gPSBbXTtcbiAgICAgIGZvciAobGV0IGQgPSBzdGFydERheTsgZCA8PSBlbmREYXk7IGQrKykge1xuICAgICAgICAvLyBTa2lwIGRheXMgYWZ0ZXIgTm92IDE0IC0gdGhleSdyZSBmZXRjaGVkIGRpcmVjdGx5LCBub3QgdGhyb3VnaCBjYWNoZVxuICAgICAgICBpZiAoZCA+PSBuZXdDb250cmFjdFN0YXJ0RGF5KSBjb250aW51ZTtcbiAgICAgICAgY29uc3QgZGF5U3RhcnQgPSBkICogODY0MDA7XG4gICAgICAgIGNvbnN0IGRheUVuZCA9IGRheVN0YXJ0ICsgODYzOTk7XG4gICAgICAgIGRheVJhbmdlcy5wdXNoKHsga2V5OiBkLCBzdGFydDogTWF0aC5tYXgoZGF5U3RhcnQsIHNUcyksIGVuZDogTWF0aC5taW4oZGF5RW5kLCBiZWZvcmVOZXdDb250cmFjdEVuZCkgfSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IENPTkMgPSBNYXRoLm1heCgxLCBEQVlfUkFOR0VfQ09OQ1VSUkVOQ1kpO1xuICAgICAgZm9yIChsZXQgaT0wOyBpPGRheVJhbmdlcy5sZW5ndGg7IGkrPUNPTkMpIHtcbiAgICAgICAgY29uc3Qgc2xpY2UgPSBkYXlSYW5nZXMuc2xpY2UoaSwgaStDT05DKS5tYXAoYXN5bmMgKHIpID0+IHtcbiAgICAgICAgICBjb25zdCBpc0hpc3RvcmljYWwgPSByLmtleSA8IHRvZGF5RGF5O1xuICAgICAgICAgIGNvbnN0IGRheVN0YXJ0VHMgPSByLmtleSAqIDg2NDAwO1xuICAgICAgICAgIGNvbnN0IGRheUVuZFRzID0gZGF5U3RhcnRUcyArIDg2Mzk5O1xuICAgICAgICAgIC8vIERheXMgYWZ0ZXIgTm92IDE0IG5lZWQgbmV3IGNvbnRyYWN0IGRhdGFcbiAgICAgICAgICBjb25zdCBuZWVkc05ld0NvbnRyYWN0ID0gZGF5U3RhcnRUcyA+PSBORVdfQ09OVFJBQ1RfU1RBUlRfVFM7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gRm9yIGRheXMgYWZ0ZXIgTm92IDE0LCBhbHdheXMgdXNlIGZ1bGwgZGF5IHJhbmdlIHdoZW4gcmVidWlsZGluZ1xuICAgICAgICAgIGNvbnN0IHJlYnVpbGRTdGFydCA9IG5lZWRzTmV3Q29udHJhY3QgPyBkYXlTdGFydFRzIDogci5zdGFydDtcbiAgICAgICAgICBjb25zdCByZWJ1aWxkRW5kID0gbmVlZHNOZXdDb250cmFjdCA/IGRheUVuZFRzIDogci5lbmQ7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gRm9yIGRheXMgYWZ0ZXIgTm92IDE0OiBlbnN1cmUgd2UgaGF2ZSBjYWNoZWQgZGF0YSBmcm9tIG5ldyBjb250cmFjdFxuICAgICAgICAgIGlmIChuZWVkc05ld0NvbnRyYWN0ICYmIGlzSGlzdG9yaWNhbCkge1xuICAgICAgICAgICAgLy8gQ2hlY2sgY2FjaGUgZmlyc3QgLSBidXQgYmUgYWdncmVzc2l2ZTogaWYgY2FjaGUgaXMgZW1wdHkgb3IgZG9lc24ndCBoYXZlIG1lZ2Egcm93cywgYWx3YXlzIGZldGNoIGZyZXNoXG4gICAgICAgICAgICAvLyAxKSBUcnkgaW4tbWVtb3J5IGNhY2hlXG4gICAgICAgICAgICBjb25zdCBtZW0gPSBkYXlDYWNoZS5nZXQobWVtS2V5KHIua2V5KSk7XG4gICAgICAgICAgICBpZiAobWVtICYmIGhhc01lZ2FSb3dzKG1lbSkgJiYgbWVtLnJvd3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAvLyBDYWNoZSBoYXMgbmV3IGNvbnRyYWN0IGRhdGEgd2l0aCBhY3R1YWwgcm93cyAtIHVzZSBpdFxuICAgICAgICAgICAgICByZXN1bHRSb3dzLnB1c2goLi4ubWVtLnJvd3MpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIDIpIFRyeSBwZXJzaXN0ZW50IEtWIGNhY2hlXG4gICAgICAgICAgICBjb25zdCBmcm9tS3YgPSBhd2FpdCBrdkdldERheShyLmtleSk7XG4gICAgICAgICAgICBpZiAoZnJvbUt2ICYmIGhhc01lZ2FSb3dzKGZyb21LdikgJiYgZnJvbUt2LnJvd3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAvLyBLViBjYWNoZSBoYXMgbmV3IGNvbnRyYWN0IGRhdGEgd2l0aCBhY3R1YWwgcm93cyAtIHVzZSBpdCBhbmQgbG9hZCBpbnRvIG1lbW9yeVxuICAgICAgICAgICAgICByZW1lbWJlcihyLmtleSwgZnJvbUt2KTtcbiAgICAgICAgICAgICAgcmVzdWx0Um93cy5wdXNoKC4uLmZyb21Ldi5yb3dzKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyAzKSBDYWNoZSBkb2Vzbid0IGV4aXN0LCBpcyBlbXB0eSwgb3IgZG9lc24ndCBoYXZlIG5ldyBjb250cmFjdCBkYXRhIC0gQUxXQVlTIGZldGNoIGZyZXNoIHVzaW5nIEVYQUNUIHNhbWUgbWV0aG9kIGFzIGV4dGVuZFRvZGF5XG4gICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBwcm92ZW4gbWV0aG9kIHRoYXQgd29ya3MgZm9yIHRvZGF5XG4gICAgICAgICAgICBjb25zdCBmcm9tQmxvY2sgPSBhd2FpdCBmaW5kQmxvY2tBdE9yQWZ0ZXIocmVidWlsZFN0YXJ0LCBib3VuZHMpO1xuICAgICAgICAgICAgY29uc3QgdG9CbG9jayA9IGF3YWl0IGZpbmRCbG9ja0F0T3JCZWZvcmUocmVidWlsZEVuZCwgYm91bmRzKTtcbiAgICAgICAgICAgIGlmICh0b0Jsb2NrIDwgZnJvbUJsb2NrKSB7XG4gICAgICAgICAgICAgIC8vIE5vIGJsb2NrcyBpbiByYW5nZSAtIGRvbid0IGNhY2hlLCBqdXN0IHJldHVybiBlbXB0eSAod2lsbCByZXRyeSBuZXh0IHRpbWUpXG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gVXNlIEVYQUNUIHNhbWUgbWV0aG9kIGFzIGV4dGVuZFRvZGF5OiBnZXRMb2dzU2luZ2xlL2dldExvZ3NDaHVua2VkIHdpdGggZGVmYXVsdHMgKENPTlRSQUNUL1RPUElDMClcbiAgICAgICAgICAgIGxldCBuZXdMb2dzOiBhbnlbXSA9IFtdO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgbmV3TG9ncyA9IGF3YWl0IGdldExvZ3NTaW5nbGUoZnJvbUJsb2NrLCB0b0Jsb2NrKTtcbiAgICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgICBuZXdMb2dzID0gYXdhaXQgZ2V0TG9nc0NodW5rZWQoZnJvbUJsb2NrLCB0b0Jsb2NrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFVzZSBFWEFDVCBzYW1lIGRlY29kZSBtZXRob2QgYXMgZXh0ZW5kVG9kYXlcbiAgICAgICAgICAgIGNvbnN0IG5ld1Jvd3MgPSAobmV3TG9ncyBhcyBhbnlbXSkubWFwKGRlY29kZSkuZmlsdGVyKEJvb2xlYW4pIGFzIFJvd1tdO1xuICAgICAgICAgICAgLy8gRGVkdXBlIHNhbWUgd2F5IGFzIGV4dGVuZFRvZGF5XG4gICAgICAgICAgICBjb25zdCB1bmlxID0gbmV3IE1hcDxzdHJpbmcsIFJvdz4oKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgciBvZiBuZXdSb3dzKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGlkeE9yQmxvY2sgPSAodHlwZW9mIChyIGFzIGFueSkubG9nSW5kZXggPT09ICdudW1iZXInICYmICFpc05hTigociBhcyBhbnkpLmxvZ0luZGV4KSkgPyAociBhcyBhbnkpLmxvZ0luZGV4IDogci5ibG9ja051bWJlcjtcbiAgICAgICAgICAgICAgdW5pcS5zZXQoYCR7ci50eEhhc2h9OiR7aWR4T3JCbG9ja31gLCByKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGZldGNoZWRSb3dzID0gQXJyYXkuZnJvbSh1bmlxLnZhbHVlcygpKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc3QgZW50cnk6IERheUVudHJ5ID0ge1xuICAgICAgICAgICAgICBmcm9tQmxvY2ssXG4gICAgICAgICAgICAgIHRvQmxvY2ssXG4gICAgICAgICAgICAgIHJvd3M6IGZldGNoZWRSb3dzLFxuICAgICAgICAgICAgICBsYXN0VXBkYXRlOiBEYXRlLm5vdygpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBPbmx5IGNhY2hlIGlmIHdlIGdvdCBkYXRhIC0gZG9uJ3QgY2FjaGUgZW1wdHkgcmVzdWx0cyBmb3IgZGF5cyBhZnRlciBOb3YgMTRcbiAgICAgICAgICAgIC8vIFRoaXMgZW5zdXJlcyB3ZSBrZWVwIHJldHJ5aW5nIHVudGlsIHdlIGdldCB0aGUgZGF0YVxuICAgICAgICAgICAgaWYgKGZldGNoZWRSb3dzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgcmVtZW1iZXIoci5rZXksIGVudHJ5KTtcbiAgICAgICAgICAgICAgYXdhaXQga3ZTZXREYXkoci5rZXksIGVudHJ5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdFJvd3MucHVzaCguLi5mZXRjaGVkUm93cyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIEZvciBkYXlzIGJlZm9yZSBOb3YgMTUgb3IgdG9kYXk6IHVzZSBleGlzdGluZyBsb2dpY1xuICAgICAgICAgIC8vIDEpIFRyeSBpbi1tZW1vcnkgZmlyc3QgKGZhc3QpXG4gICAgICAgICAgY29uc3QgbWVtID0gZGF5Q2FjaGUuZ2V0KG1lbUtleShyLmtleSkpO1xuICAgICAgICAgIGlmIChtZW0pIHtcbiAgICAgICAgICAgIGlmIChpc0hpc3RvcmljYWwpIHtcbiAgICAgICAgICAgICAgLy8gVXNlIGNhY2hlIGFzLWlzXG4gICAgICAgICAgICAgIHJlc3VsdFJvd3MucHVzaCguLi5tZW0ucm93cyk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIFRvZGF5OiBleHRlbmQgd2l0aCBsYXRlc3QgZGF0YVxuICAgICAgICAgICAgICBjb25zdCB1cGRhdGVkID0gYXdhaXQgZXh0ZW5kVG9kYXkobWVtLCByLnN0YXJ0LCByLmVuZCwgYm91bmRzKTtcbiAgICAgICAgICAgICAgcmVtZW1iZXIoci5rZXksIHVwZGF0ZWQpO1xuICAgICAgICAgICAgICBhd2FpdCBrdlNldERheShyLmtleSwgdXBkYXRlZCk7XG4gICAgICAgICAgICAgIHJlc3VsdFJvd3MucHVzaCguLi51cGRhdGVkLnJvd3MpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gMikgVHJ5IHBlcnNpc3RlbnQgS1ZcbiAgICAgICAgICBjb25zdCBmcm9tS3YgPSBhd2FpdCBrdkdldERheShyLmtleSk7XG4gICAgICAgICAgaWYgKGZyb21Ldikge1xuICAgICAgICAgICAgaWYgKGlzSGlzdG9yaWNhbCkge1xuICAgICAgICAgICAgICAvLyBVc2UgY2FjaGUgYXMtaXMsIGxvYWQgaW50byBtZW1vcnkgZm9yIG5leHQgdGltZVxuICAgICAgICAgICAgICByZW1lbWJlcihyLmtleSwgZnJvbUt2KTtcbiAgICAgICAgICAgICAgcmVzdWx0Um93cy5wdXNoKC4uLmZyb21Ldi5yb3dzKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gVG9kYXk6IGV4dGVuZCB3aXRoIGxhdGVzdCBkYXRhXG4gICAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWQgPSBhd2FpdCBleHRlbmRUb2RheShmcm9tS3YsIHIuc3RhcnQsIHIuZW5kLCBib3VuZHMpO1xuICAgICAgICAgICAgICByZW1lbWJlcihyLmtleSwgdXBkYXRlZCk7XG4gICAgICAgICAgICAgIGF3YWl0IGt2U2V0RGF5KHIua2V5LCB1cGRhdGVkKTtcbiAgICAgICAgICAgICAgcmVzdWx0Um93cy5wdXNoKC4uLnVwZGF0ZWQucm93cyk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyAzKSBCdWlsZCBmcmVzaCBhbmQgcGVyc2lzdFxuICAgICAgICAgIGNvbnN0IGJ1aWx0ID0gYXdhaXQgYnVpbGREYXkocmVidWlsZFN0YXJ0LCByZWJ1aWxkRW5kLCBib3VuZHMpO1xuICAgICAgICAgIHJlbWVtYmVyKGJ1aWx0LmtleSwgYnVpbHQuZW50cnkpO1xuICAgICAgICAgIGF3YWl0IGt2U2V0RGF5KGJ1aWx0LmtleSwgYnVpbHQuZW50cnkpO1xuICAgICAgICAgIHJlc3VsdFJvd3MucHVzaCguLi5idWlsdC5lbnRyeS5yb3dzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHNsaWNlKTtcbiAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gRmV0Y2ggZGF5cyBhZnRlciBOb3YgMTQ6IGZldGNoIGRheS1ieS1kYXkgdG8gYXZvaWQgYmxvY2sgcmFuZ2UgbGltaXRzLCB0aGVuIGNhY2hlXG4gICAgICBpZiAoZVRzID49IE5FV19DT05UUkFDVF9TVEFSVF9UUykge1xuICAgICAgICBjb25zdCB0b2RheURheSA9IE1hdGguZmxvb3IobGF0ZXN0LnRzIC8gODY0MDApO1xuICAgICAgICBjb25zdCB0b2RheVN0YXJ0VHMgPSB0b2RheURheSAqIDg2NDAwO1xuICAgICAgICBjb25zdCBmZXRjaEVuZCA9IE1hdGgubWluKGVUcywgdG9kYXlTdGFydFRzIC0gMSk7IC8vIEV4Y2x1ZGUgdG9kYXlcbiAgICAgICAgXG4gICAgICAgIGlmIChmZXRjaEVuZCA+PSBhZnRlck5ld0NvbnRyYWN0U3RhcnQpIHtcbiAgICAgICAgICBjb25zdCBuZXdDb250cmFjdFN0YXJ0RGF5ID0gTWF0aC5mbG9vcihhZnRlck5ld0NvbnRyYWN0U3RhcnQgLyA4NjQwMCk7XG4gICAgICAgICAgY29uc3QgbmV3Q29udHJhY3RFbmREYXkgPSBNYXRoLmZsb29yKGZldGNoRW5kIC8gODY0MDApO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEZldGNoIGRheS1ieS1kYXkgaW4gcGFyYWxsZWwgKGJ1dCBsaW1pdCBjb25jdXJyZW5jeSB0byBhdm9pZCBvdmVyd2hlbG1pbmcgUlBDKVxuICAgICAgICAgIGNvbnN0IENPTkMgPSBNYXRoLm1pbig1LCBuZXdDb250cmFjdEVuZERheSAtIG5ld0NvbnRyYWN0U3RhcnREYXkgKyAxKTtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBuZXdDb250cmFjdEVuZERheSAtIG5ld0NvbnRyYWN0U3RhcnREYXk7IGkgKz0gQ09OQykge1xuICAgICAgICAgICAgY29uc3Qgc2xpY2UgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgQ09OQyAmJiAobmV3Q29udHJhY3RTdGFydERheSArIGkgKyBqKSA8PSBuZXdDb250cmFjdEVuZERheTsgaisrKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGQgPSBuZXdDb250cmFjdFN0YXJ0RGF5ICsgaSArIGo7XG4gICAgICAgICAgICAgIGNvbnN0IGRheVN0YXJ0VHMgPSBkICogODY0MDA7XG4gICAgICAgICAgICAgIGNvbnN0IGRheUVuZFRzID0gZGF5U3RhcnRUcyArIDg2Mzk5O1xuICAgICAgICAgICAgICBjb25zdCBkYXlTdGFydCA9IE1hdGgubWF4KGRheVN0YXJ0VHMsIGFmdGVyTmV3Q29udHJhY3RTdGFydCk7XG4gICAgICAgICAgICAgIGNvbnN0IGRheUVuZCA9IE1hdGgubWluKGRheUVuZFRzLCBmZXRjaEVuZCk7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBzbGljZS5wdXNoKChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgY2FjaGUgZmlyc3RcbiAgICAgICAgICAgICAgICBsZXQgY2FjaGVkOiBEYXlFbnRyeSB8IG51bGwgPSBudWxsO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1lbSA9IGRheUNhY2hlLmdldChtZW1LZXkoZCkpO1xuICAgICAgICAgICAgICAgIGlmIChtZW0gJiYgaGFzTWVnYVJvd3MobWVtKSAmJiBtZW0ucm93cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbWVtLnJvd3M7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGZyb21LdiA9IGF3YWl0IGt2R2V0RGF5KGQpO1xuICAgICAgICAgICAgICAgIGlmIChmcm9tS3YgJiYgaGFzTWVnYVJvd3MoZnJvbUt2KSAmJiBmcm9tS3Yucm93cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICByZW1lbWJlcihkLCBmcm9tS3YpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZyb21Ldi5yb3dzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBOb3QgaW4gY2FjaGUgLSBmZXRjaCB0aGlzIGRheVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBmZXRjaGVkUm93cyA9IGF3YWl0IGZldGNoUmFuZ2VSb3dzRGlyZWN0KGRheVN0YXJ0LCBkYXlFbmQsIGJvdW5kcyk7XG4gICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgIC8vIENhY2hlIHRoZSByZXN1bHRzXG4gICAgICAgICAgICAgICAgICBpZiAoZmV0Y2hlZFJvd3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZnJvbUJsb2NrOiBudW1iZXI7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0b0Jsb2NrOiBudW1iZXI7XG4gICAgICAgICAgICAgICAgICAgIGZyb21CbG9jayA9IE1hdGgubWluKC4uLmZldGNoZWRSb3dzLm1hcChyID0+IHIuYmxvY2tOdW1iZXIpKTtcbiAgICAgICAgICAgICAgICAgICAgdG9CbG9jayA9IE1hdGgubWF4KC4uLmZldGNoZWRSb3dzLm1hcChyID0+IHIuYmxvY2tOdW1iZXIpKTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVudHJ5OiBEYXlFbnRyeSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICBmcm9tQmxvY2ssXG4gICAgICAgICAgICAgICAgICAgICAgdG9CbG9jayxcbiAgICAgICAgICAgICAgICAgICAgICByb3dzOiBmZXRjaGVkUm93cyxcbiAgICAgICAgICAgICAgICAgICAgICBsYXN0VXBkYXRlOiBEYXRlLm5vdygpXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICByZW1lbWJlcihkLCBlbnRyeSk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGt2U2V0RGF5KGQsIGVudHJ5KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZldGNoZWRSb3dzO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycjogYW55KSB7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBGYWlsZWQgdG8gZmV0Y2ggZGF5ICR7ZH1gLCB7IGVycm9yOiBlcnI/Lm1lc3NhZ2UgfHwgU3RyaW5nKGVyciksIGRheVN0YXJ0LCBkYXlFbmQgfSk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gW10gYXMgUm93W107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc3QgZGF5UmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKHNsaWNlKTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgcm93cyBvZiBkYXlSZXN1bHRzKSB7XG4gICAgICAgICAgICAgIHJlc3VsdFJvd3MgPSBtZXJnZVJvd3MocmVzdWx0Um93cywgcm93cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gT25seSBkbyBsaXZlIGZldGNoIGZvciB0b2RheSdzIGRhdGEgKHRvIGdldCBsYXRlc3QgbWF0Y2hlcyksIHNraXAgZm9yIGhpc3RvcmljYWwgZGF0ZXNcbiAgICBjb25zdCB0b2RheURheSA9IE1hdGguZmxvb3IobGF0ZXN0LnRzIC8gODY0MDApO1xuICAgIGNvbnN0IGVuZERheSA9IE1hdGguZmxvb3IoZVRzIC8gODY0MDApO1xuICAgIGlmIChlbmREYXkgPj0gdG9kYXlEYXkpIHtcbiAgICAgIC8vIFJlcXVlc3QgaW5jbHVkZXMgdG9kYXkgLSBmZXRjaCBsaXZlIGRhdGEgZm9yIHRvZGF5IG9ubHlcbiAgICAgIGNvbnN0IHRvZGF5U3RhcnRUcyA9IHRvZGF5RGF5ICogODY0MDA7XG4gICAgICBjb25zdCBsaXZlU3RhcnRUcyA9IE1hdGgubWF4KHNUcywgdG9kYXlTdGFydFRzKTtcbiAgICAgIGlmIChsaXZlU3RhcnRUcyA8PSBlVHMpIHtcbiAgICAgICAgY29uc3QgbGl2ZVJvd3MgPSBhd2FpdCBmZXRjaFJhbmdlUm93c0RpcmVjdChsaXZlU3RhcnRUcywgZVRzLCBib3VuZHMpO1xuICAgICAgICByZXN1bHRSb3dzID0gbWVyZ2VSb3dzKHJlc3VsdFJvd3MsIGxpdmVSb3dzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0Um93cy5zb3J0KHNvcnRCeVRpbWVzdGFtcCk7XG5cbiAgICAvLyBGaXJzdCBjb25zdHJhaW4gcHJlY2lzZWx5IHRvIHRoZSByZXF1ZXN0ZWQgW3NUcywgZVRzXSB3aW5kb3cgKGV2ZW4gaWYgY2FjaGVkIGZ1bGwgZGF5cyB3ZXJlIHVzZWQpXG4gICAgY29uc3Qgd2luZG93ZWQgPSBmaWx0ZXJSb3dzQnlUcyhyZXN1bHRSb3dzLCBzVHMsIGVUcyk7XG5cbiAgICAvLyBGaW5hbCBkZWZlbnNpdmUgcGFzczogZGVkdXBlIGFjcm9zcyBkYXlzIGFuZCBjYWNoZSBmb3JtYXRzXG4gICAgY29uc3QgYnlLZXkgPSBuZXcgTWFwPHN0cmluZywgUm93PigpO1xuICAgIGZvciAoY29uc3QgciBvZiB3aW5kb3dlZCkgYnlLZXkuc2V0KHN0YWJsZVJvd0tleShyKSwgcik7XG4gICAgY29uc3Qgb3V0ID0gQXJyYXkuZnJvbShieUtleS52YWx1ZXMoKSk7XG4gICAgb3V0LnNvcnQoc29ydEJ5VGltZXN0YW1wKTtcbiAgICBpZiAod2FudEFnZykge1xuICAgICAgY29uc3QgYWdnID0gY29tcHV0ZUFnZyhvdXQpO1xuICAgICAgcmV0dXJuIHNlbmRKc29uKHJlcywgMjAwLCB7IG9rOiB0cnVlLCByb3dzOiBvdXQsIGFnZ0J5Q2xhc3M6IGFnZy5ieUNsYXNzLCBhZ2dMYXN0VXBkYXRlOiBhZ2cubGFzdFVwZGF0ZSB9KTtcbiAgICB9XG4gICAgc2VuZEpzb24ocmVzLCAyMDAsIHsgb2s6IHRydWUsIHJvd3M6IG91dCB9KTtcbiAgfSBjYXRjaCAoZTphbnkpIHtcbiAgICBzZW5kSnNvbihyZXMsIDIwMCwgeyBvazogZmFsc2UsIGVycm9yOiBlPy5tZXNzYWdlIHx8IFN0cmluZyhlKSB9KTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbIkludGVyZmFjZSIsImd6aXBTeW5jIiwiUlBDIiwicHJvY2VzcyIsImVudiIsIlJQQ19VUkwiLCJDT05UUkFDVCIsIkNPTlRSQUNUX0FERFJFU1MiLCJ0b0xvd2VyQ2FzZSIsIkxFR0FDWV9DT05UUkFDVCIsIkxFR0FDWV9UT1BJQzAiLCJUT1BJQzAiLCJORVdfQ09OVFJBQ1RfU1RBUlRfVFMiLCJNYXRoIiwiZmxvb3IiLCJEYXRlIiwiZ2V0VGltZSIsIk1BWF9TUEFOIiwiTUFYX0RBWVNfQ0FDSEUiLCJSUENfUkVUUllfQVRURU1QVFMiLCJSUENfQkFTRV9ERUxBWV9NUyIsIkRBWV9SQU5HRV9DT05DVVJSRU5DWSIsIkxPR19SQU5HRV9DT05DVVJSRU5DWSIsIkNBQ0hFX05BTUVTUEFDRSIsIm1lbUtleSIsImRheUluZGV4IiwiZGF5Q2FjaGUiLCJNYXAiLCJkYXlPcmRlciIsInJlbWVtYmVyIiwiZW50cnkiLCJrZXkiLCJoYXMiLCJwdXNoIiwic2V0IiwibGVuZ3RoIiwiZXZpY3QiLCJzaGlmdCIsInVuZGVmaW5lZCIsImRlbGV0ZSIsImRheUluZGV4RnJvbVRzIiwidHMiLCJjbGFtcCIsIm4iLCJhIiwiYiIsIm1heCIsIm1pbiIsIktWX0VOVl9QUkVTRU5UIiwiS1ZfUkVTVF9BUElfVVJMIiwiVVBTVEFTSF9SRURJU19SRVNUX1VSTCIsImt2S2V5Iiwia3ZBZ2dLZXkiLCJsZWdhY3lLdktleSIsImxlZ2FjeUt2QWdnS2V5IiwiX2t2Q2xpZW50IiwiZ2V0S3YiLCJLVl9SRVNUX0FQSV9UT0tFTiIsIlVQU1RBU0hfUkVESVNfUkVTVF9UT0tFTiIsIm1vZCIsImt2Iiwia3ZHZXREYXkiLCJjbGllbnQiLCJkYXlTdGFydFRzIiwibmVlZHNOZXdDb250cmFjdCIsIm5ld0tleSIsImdldCIsImxlZ2FjeUtleSIsIlByb21pc2UiLCJhbGwiLCJjb21wdXRlQWdnIiwicm93cyIsIm1hcCIsInIiLCJ3Iiwid2lubmluZ0NsYXNzZXMiLCJ0cmltIiwibCIsImxvc2luZ0NsYXNzZXMiLCJ3aW5zIiwibG9zc2VzIiwidG90YWwiLCJieUNsYXNzIiwibGFzdFVwZGF0ZSIsIm5vdyIsImt2U2V0RGF5IiwiYWdnIiwiaWZhY2UiLCJsZWdhY3lJZmFjZSIsInRvSGV4IiwidG9TdHJpbmciLCJzbGVlcCIsIm1zIiwic2V0VGltZW91dCIsIm5vcm1hbGl6ZVBsYXllciIsInJhdyIsInZhbCIsImlkeCIsImluZGV4T2YiLCJzbGljZSIsInNlbmRKc29uIiwicmVzIiwic3RhdHVzIiwicGF5bG9hZCIsImpzb24iLCJKU09OIiwic3RyaW5naWZ5IiwiZ3oiLCJzZXRIZWFkZXIiLCJzZW5kIiwicnBjIiwiYm9keSIsImF0dGVtcHRzIiwiYmFzZURlbGF5IiwibGFzdEVyciIsImkiLCJmZXRjaCIsIm1ldGhvZCIsImhlYWRlcnMiLCJFcnJvciIsInJldHJ5QWZ0ZXIiLCJOdW1iZXIiLCJ3YWl0Iiwicm91bmQiLCJwb3ciLCJvayIsImoiLCJBcnJheSIsImlzQXJyYXkiLCJiYWQiLCJmaW5kIiwieCIsImVycm9yIiwibWVzc2FnZSIsImUiLCJnZXRCbG9ja0J5VGFnIiwidGFnIiwianNvbnJwYyIsImlkIiwicGFyYW1zIiwiYmxrIiwicmVzdWx0IiwibnVtIiwicGFyc2VJbnQiLCJudW1iZXIiLCJ0aW1lc3RhbXAiLCJnZXRCbG9ja0J5TnVtYmVyIiwiZ2V0RWFybGllc3QiLCJnZXRMYXRlc3QiLCJmaW5kQmxvY2tBdE9yQWZ0ZXIiLCJ0YXJnZXRUcyIsImJvdW5kcyIsImVhcmxpZXN0IiwibGF0ZXN0IiwiY2xhbXBlZCIsImxvIiwiaGkiLCJtaWQiLCJmaW5kQmxvY2tBdE9yQmVmb3JlIiwiYnVpbGRSYW5nZXMiLCJmcm9tQmxvY2siLCJ0b0Jsb2NrIiwicmFuZ2VzIiwicyIsImZyb20iLCJ0byIsImdldExvZ3NTaW5nbGUiLCJjb250cmFjdCIsInRvcGljMCIsImFkZHJlc3MiLCJ0b3BpY3MiLCJhcnIiLCJ1bmlxIiwibG9nIiwidHJhbnNhY3Rpb25IYXNoIiwibG9nSW5kZXgiLCJ2YWx1ZXMiLCJnZXRMb2dzQ2h1bmtlZCIsIkNPTkNVUlJFTkNZIiwicmVxcyIsInBhcnRzIiwicCIsImRlY29kZSIsInBhcnNlZCIsInBhcnNlTG9nIiwiZGF0YSIsImdhbWVOdW1iZXIiLCJnYW1lSWQiLCJzdGFydGVkQXQiLCJ3aW5uaW5nUGxheWVyIiwibG9zaW5nUGxheWVyIiwiZ2FtZUxlbmd0aCIsImVuZFJlYXNvbiIsImdhbWVUeXBlIiwibWV0YWRhdGEiLCJhcmdzIiwiYmxvY2tOdW1iZXIiLCJ0eEhhc2giLCJTdHJpbmciLCJuZXR3b3JrIiwiZGVjb2RlTGVnYWN5IiwiZGVjb2RlTG9ncyIsImxvZ3MiLCJpc0xlZ2FjeSIsImRlY29kZXIiLCJmaWx0ZXIiLCJCb29sZWFuIiwiZGVkdXBlUm93cyIsImlkeE9yQmxvY2siLCJpc05hTiIsIm1lcmdlUm93cyIsInN0YWJsZVJvd0tleSIsImhhc01lZ2FSb3dzIiwic29tZSIsIm1lcmdlRGF5RW50cmllcyIsInNvcnQiLCJzb3J0QnlUaW1lc3RhbXAiLCJlbnN1cmVNZWdhUm93cyIsImRheUVuZFRzIiwiYnVpbHQiLCJidWlsZERheSIsIm1lcmdlZCIsInBhcnNlU3RhcnRlZEF0VHMiLCJzdHIiLCJtIiwiZXhlYyIsInllYXIiLCJtb250aCIsImRheSIsImhvdXIiLCJtaW51dGUiLCJzZWNvbmQiLCJVVEMiLCJpc28iLCJyZXBsYWNlIiwicGFyc2UiLCJ0c0EiLCJ0c0IiLCJmaWx0ZXJSb3dzQnlUcyIsInN0YXJ0VHMiLCJlbmRUcyIsImFueVIiLCJzYWZlU3RhcnQiLCJpc0xlZ2FjeURheSIsImV4dGVuZFRvZGF5IiwiZXhpc3RpbmciLCJuZXdMb2dzIiwibmV3Um93cyIsImZldGNoUmFuZ2VSb3dzRGlyZWN0IiwiY2xhbXBlZFN0YXJ0IiwiY2xhbXBlZEVuZCIsIm5lZWRzTGVnYWN5IiwibmVlZHNOZXciLCJxdWVyaWVzIiwibGVnYWN5RW5kVHMiLCJsZWdhY3lGcm9tQmxvY2siLCJsZWdhY3lUb0Jsb2NrIiwibmV3U3RhcnRUcyIsIm5ld0Zyb21CbG9jayIsIm5ld1RvQmxvY2siLCJkZWNvZGVkIiwiZGVkdXBlZCIsImNvbnNvbGUiLCJsb2dzTGVuZ3RoIiwiZXJyIiwiY2h1bmtFcnIiLCJyZXN1bHRzIiwicXVlcmllc0NvdW50IiwiYWxsUm93cyIsInJlc3VsdHNMZW5ndGhzIiwiaGFuZGxlciIsInJlcSIsInJlYnVpbGREYXkiLCJ3YW50QWdnIiwic3RhcnQiLCJlbmQiLCJyZWJ1aWx0Iiwic1RzIiwiZVRzIiwicmVzdWx0Um93cyIsImJlZm9yZU5ld0NvbnRyYWN0RW5kIiwiYWZ0ZXJOZXdDb250cmFjdFN0YXJ0Iiwic3RhcnREYXkiLCJlbmREYXkiLCJ0b2RheURheSIsIm5ld0NvbnRyYWN0U3RhcnREYXkiLCJkYXlSYW5nZXMiLCJkIiwiZGF5U3RhcnQiLCJkYXlFbmQiLCJDT05DIiwiaXNIaXN0b3JpY2FsIiwicmVidWlsZFN0YXJ0IiwicmVidWlsZEVuZCIsIm1lbSIsImZyb21LdiIsImZldGNoZWRSb3dzIiwidXBkYXRlZCIsInRvZGF5U3RhcnRUcyIsImZldGNoRW5kIiwibmV3Q29udHJhY3RFbmREYXkiLCJjYWNoZWQiLCJkYXlSZXN1bHRzIiwibGl2ZVN0YXJ0VHMiLCJsaXZlUm93cyIsIndpbmRvd2VkIiwiYnlLZXkiLCJvdXQiLCJhZ2dCeUNsYXNzIiwiYWdnTGFzdFVwZGF0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/./pages/api/eth.ts\n");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../webpack-api-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next"], () => (__webpack_exec__("(api)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Feth&preferredRegion=&absolutePagePath=.%2Fpages%2Fapi%2Feth.ts&middlewareConfigBase64=e30%3D!")));
module.exports = __webpack_exports__;

})();